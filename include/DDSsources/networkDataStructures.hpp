/****************************************************************

  Generated by Eclipse Cyclone DDS IDL to CXX Translator
  File name: /home/eric-wsl/CProjects/UEIDAQ-core-boost-cycloneDDScxx/networkDataStructures.idl
  Source: /home/eric-wsl/CProjects/UEIDAQ-core-boost-cycloneDDScxx/build/networkDataStructures.hpp
  Cyclone DDS: v0.11.0

*****************************************************************/
#ifndef DDSCXX__HOME_ERICWSL_CPROJECTS_UEIDAQ_CORE_BOOST_CYCLONEDDSCXX_BUILD_NETWORKDATASTRUCTURES_HPP_766278EA1375CB10BEDF72992B227068
#define DDSCXX__HOME_ERICWSL_CPROJECTS_UEIDAQ_CORE_BOOST_CYCLONEDDSCXX_BUILD_NETWORKDATASTRUCTURES_HPP_766278EA1375CB10BEDF72992B227068

#include <utility>
#include <cstdint>
#include <array>
#include <string>

namespace networkDataStructures
{
class Msg
{
private:
 int32_t userID_ = 0;
 std::string message_;

public:
  Msg() = default;

  explicit Msg(
    int32_t userID,
    const std::string& message) :
    userID_(userID),
    message_(message) { }

  int32_t userID() const { return this->userID_; }
  int32_t& userID() { return this->userID_; }
  void userID(int32_t _val_) { this->userID_ = _val_; }
  const std::string& message() const { return this->message_; }
  std::string& message() { return this->message_; }
  void message(const std::string& _val_) { this->message_ = _val_; }
  void message(std::string&& _val_) { this->message_ = std::move(_val_); }

  bool operator==(const Msg& _other) const
  {
    (void) _other;
    return userID_ == _other.userID_ &&
      message_ == _other.message_;
  }

  bool operator!=(const Msg& _other) const
  {
    return !(*this == _other);
  }

};

class ChInfo
{
private:
 uint32_t machineID_ = 0;
 std::string ChInfoString_;

public:
  ChInfo() = default;

  explicit ChInfo(
    uint32_t machineID,
    const std::string& ChInfoString) :
    machineID_(machineID),
    ChInfoString_(ChInfoString) { }

  uint32_t machineID() const { return this->machineID_; }
  uint32_t& machineID() { return this->machineID_; }
  void machineID(uint32_t _val_) { this->machineID_ = _val_; }
  const std::string& ChInfoString() const { return this->ChInfoString_; }
  std::string& ChInfoString() { return this->ChInfoString_; }
  void ChInfoString(const std::string& _val_) { this->ChInfoString_ = _val_; }
  void ChInfoString(std::string&& _val_) { this->ChInfoString_ = std::move(_val_); }

  bool operator==(const ChInfo& _other) const
  {
    (void) _other;
    return machineID_ == _other.machineID_ &&
      ChInfoString_ == _other.ChInfoString_;
  }

  bool operator!=(const ChInfo& _other) const
  {
    return !(*this == _other);
  }

};

class BundleStruct
{
private:
 uint32_t machineID_ = 0;
 uint64_t iteration_ = 0;
 std::array<double, 8> aiBundle_ = { };
 std::array<double, 8> aoBundle_ = { };
 std::array<bool, 12> roBundle_ = { };
 std::array<double, 24> calcBundle_ = { };

public:
  BundleStruct() = default;

  explicit BundleStruct(
    uint32_t machineID,
    uint64_t iteration,
    const std::array<double, 8>& aiBundle,
    const std::array<double, 8>& aoBundle,
    const std::array<bool, 12>& roBundle,
    const std::array<double, 24>& calcBundle) :
    machineID_(machineID),
    iteration_(iteration),
    aiBundle_(aiBundle),
    aoBundle_(aoBundle),
    roBundle_(roBundle),
    calcBundle_(calcBundle) { }

  uint32_t machineID() const { return this->machineID_; }
  uint32_t& machineID() { return this->machineID_; }
  void machineID(uint32_t _val_) { this->machineID_ = _val_; }
  uint64_t iteration() const { return this->iteration_; }
  uint64_t& iteration() { return this->iteration_; }
  void iteration(uint64_t _val_) { this->iteration_ = _val_; }
  const std::array<double, 8>& aiBundle() const { return this->aiBundle_; }
  std::array<double, 8>& aiBundle() { return this->aiBundle_; }
  void aiBundle(const std::array<double, 8>& _val_) { this->aiBundle_ = _val_; }
  void aiBundle(std::array<double, 8>&& _val_) { this->aiBundle_ = std::move(_val_); }
  const std::array<double, 8>& aoBundle() const { return this->aoBundle_; }
  std::array<double, 8>& aoBundle() { return this->aoBundle_; }
  void aoBundle(const std::array<double, 8>& _val_) { this->aoBundle_ = _val_; }
  void aoBundle(std::array<double, 8>&& _val_) { this->aoBundle_ = std::move(_val_); }
  const std::array<bool, 12>& roBundle() const { return this->roBundle_; }
  std::array<bool, 12>& roBundle() { return this->roBundle_; }
  void roBundle(const std::array<bool, 12>& _val_) { this->roBundle_ = _val_; }
  void roBundle(std::array<bool, 12>&& _val_) { this->roBundle_ = std::move(_val_); }
  const std::array<double, 24>& calcBundle() const { return this->calcBundle_; }
  std::array<double, 24>& calcBundle() { return this->calcBundle_; }
  void calcBundle(const std::array<double, 24>& _val_) { this->calcBundle_ = _val_; }
  void calcBundle(std::array<double, 24>&& _val_) { this->calcBundle_ = std::move(_val_); }

  bool operator==(const BundleStruct& _other) const
  {
    (void) _other;
    return machineID_ == _other.machineID_ &&
      iteration_ == _other.iteration_ &&
      aiBundle_ == _other.aiBundle_ &&
      aoBundle_ == _other.aoBundle_ &&
      roBundle_ == _other.roBundle_ &&
      calcBundle_ == _other.calcBundle_;
  }

  bool operator!=(const BundleStruct& _other) const
  {
    return !(*this == _other);
  }

};

class PIDIO
{
private:
 uint32_t channel_ = 0;
 double PV_ = 0.0;
 double SP_ = 0.0;
 double OP_ = 0.0;
 double manOP_ = 0.0;

public:
  PIDIO() = default;

  explicit PIDIO(
    uint32_t channel,
    double PV,
    double SP,
    double OP,
    double manOP) :
    channel_(channel),
    PV_(PV),
    SP_(SP),
    OP_(OP),
    manOP_(manOP) { }

  uint32_t channel() const { return this->channel_; }
  uint32_t& channel() { return this->channel_; }
  void channel(uint32_t _val_) { this->channel_ = _val_; }
  double PV() const { return this->PV_; }
  double& PV() { return this->PV_; }
  void PV(double _val_) { this->PV_ = _val_; }
  double SP() const { return this->SP_; }
  double& SP() { return this->SP_; }
  void SP(double _val_) { this->SP_ = _val_; }
  double OP() const { return this->OP_; }
  double& OP() { return this->OP_; }
  void OP(double _val_) { this->OP_ = _val_; }
  double manOP() const { return this->manOP_; }
  double& manOP() { return this->manOP_; }
  void manOP(double _val_) { this->manOP_ = _val_; }

  bool operator==(const PIDIO& _other) const
  {
    (void) _other;
    return channel_ == _other.channel_ &&
      PV_ == _other.PV_ &&
      SP_ == _other.SP_ &&
      OP_ == _other.OP_ &&
      manOP_ == _other.manOP_;
  }

  bool operator!=(const PIDIO& _other) const
  {
    return !(*this == _other);
  }

};

class PIDCoeff
{
private:
 uint32_t channel_ = 0;
 std::string controlName_;
 double kP_ = 0.0;
 double kI_ = 0.0;
 double kD_ = 0.0;
 double bias_ = 0.0;
 double outputMax_ = 0.0;
 double outputMin_ = 0.0;
 double windupMax_ = 0.0;
 double windupMin_ = 0.0;
 double deadbandMax_ = 0.0;
 double deadbandMin_ = 0.0;
 uint32_t inputMap_ = 0;
 uint32_t outputMap_ = 0;
 double voltsConversion_ = 0.0;
 uint32_t controlUpdateSelector_ = 0;

public:
  PIDCoeff() = default;

  explicit PIDCoeff(
    uint32_t channel,
    const std::string& controlName,
    double kP,
    double kI,
    double kD,
    double bias,
    double outputMax,
    double outputMin,
    double windupMax,
    double windupMin,
    double deadbandMax,
    double deadbandMin,
    uint32_t inputMap,
    uint32_t outputMap,
    double voltsConversion,
    uint32_t controlUpdateSelector) :
    channel_(channel),
    controlName_(controlName),
    kP_(kP),
    kI_(kI),
    kD_(kD),
    bias_(bias),
    outputMax_(outputMax),
    outputMin_(outputMin),
    windupMax_(windupMax),
    windupMin_(windupMin),
    deadbandMax_(deadbandMax),
    deadbandMin_(deadbandMin),
    inputMap_(inputMap),
    outputMap_(outputMap),
    voltsConversion_(voltsConversion),
    controlUpdateSelector_(controlUpdateSelector) { }

  uint32_t channel() const { return this->channel_; }
  uint32_t& channel() { return this->channel_; }
  void channel(uint32_t _val_) { this->channel_ = _val_; }
  const std::string& controlName() const { return this->controlName_; }
  std::string& controlName() { return this->controlName_; }
  void controlName(const std::string& _val_) { this->controlName_ = _val_; }
  void controlName(std::string&& _val_) { this->controlName_ = std::move(_val_); }
  double kP() const { return this->kP_; }
  double& kP() { return this->kP_; }
  void kP(double _val_) { this->kP_ = _val_; }
  double kI() const { return this->kI_; }
  double& kI() { return this->kI_; }
  void kI(double _val_) { this->kI_ = _val_; }
  double kD() const { return this->kD_; }
  double& kD() { return this->kD_; }
  void kD(double _val_) { this->kD_ = _val_; }
  double bias() const { return this->bias_; }
  double& bias() { return this->bias_; }
  void bias(double _val_) { this->bias_ = _val_; }
  double outputMax() const { return this->outputMax_; }
  double& outputMax() { return this->outputMax_; }
  void outputMax(double _val_) { this->outputMax_ = _val_; }
  double outputMin() const { return this->outputMin_; }
  double& outputMin() { return this->outputMin_; }
  void outputMin(double _val_) { this->outputMin_ = _val_; }
  double windupMax() const { return this->windupMax_; }
  double& windupMax() { return this->windupMax_; }
  void windupMax(double _val_) { this->windupMax_ = _val_; }
  double windupMin() const { return this->windupMin_; }
  double& windupMin() { return this->windupMin_; }
  void windupMin(double _val_) { this->windupMin_ = _val_; }
  double deadbandMax() const { return this->deadbandMax_; }
  double& deadbandMax() { return this->deadbandMax_; }
  void deadbandMax(double _val_) { this->deadbandMax_ = _val_; }
  double deadbandMin() const { return this->deadbandMin_; }
  double& deadbandMin() { return this->deadbandMin_; }
  void deadbandMin(double _val_) { this->deadbandMin_ = _val_; }
  uint32_t inputMap() const { return this->inputMap_; }
  uint32_t& inputMap() { return this->inputMap_; }
  void inputMap(uint32_t _val_) { this->inputMap_ = _val_; }
  uint32_t outputMap() const { return this->outputMap_; }
  uint32_t& outputMap() { return this->outputMap_; }
  void outputMap(uint32_t _val_) { this->outputMap_ = _val_; }
  double voltsConversion() const { return this->voltsConversion_; }
  double& voltsConversion() { return this->voltsConversion_; }
  void voltsConversion(double _val_) { this->voltsConversion_ = _val_; }
  uint32_t controlUpdateSelector() const { return this->controlUpdateSelector_; }
  uint32_t& controlUpdateSelector() { return this->controlUpdateSelector_; }
  void controlUpdateSelector(uint32_t _val_) { this->controlUpdateSelector_ = _val_; }

  bool operator==(const PIDCoeff& _other) const
  {
    (void) _other;
    return channel_ == _other.channel_ &&
      controlName_ == _other.controlName_ &&
      kP_ == _other.kP_ &&
      kI_ == _other.kI_ &&
      kD_ == _other.kD_ &&
      bias_ == _other.bias_ &&
      outputMax_ == _other.outputMax_ &&
      outputMin_ == _other.outputMin_ &&
      windupMax_ == _other.windupMax_ &&
      windupMin_ == _other.windupMin_ &&
      deadbandMax_ == _other.deadbandMax_ &&
      deadbandMin_ == _other.deadbandMin_ &&
      inputMap_ == _other.inputMap_ &&
      outputMap_ == _other.outputMap_ &&
      voltsConversion_ == _other.voltsConversion_ &&
      controlUpdateSelector_ == _other.controlUpdateSelector_;
  }

  bool operator!=(const PIDCoeff& _other) const
  {
    return !(*this == _other);
  }

};

class PIDControls
{
private:
 uint32_t channel_ = 0;
 double setpoint_ = 0.0;
 double manualOP_ = 0.0;
 bool autoCtrl_ = false;
 bool clamped_ = false;

public:
  PIDControls() = default;

  explicit PIDControls(
    uint32_t channel,
    double setpoint,
    double manualOP,
    bool autoCtrl,
    bool clamped) :
    channel_(channel),
    setpoint_(setpoint),
    manualOP_(manualOP),
    autoCtrl_(autoCtrl),
    clamped_(clamped) { }

  uint32_t channel() const { return this->channel_; }
  uint32_t& channel() { return this->channel_; }
  void channel(uint32_t _val_) { this->channel_ = _val_; }
  double setpoint() const { return this->setpoint_; }
  double& setpoint() { return this->setpoint_; }
  void setpoint(double _val_) { this->setpoint_ = _val_; }
  double manualOP() const { return this->manualOP_; }
  double& manualOP() { return this->manualOP_; }
  void manualOP(double _val_) { this->manualOP_ = _val_; }
  bool autoCtrl() const { return this->autoCtrl_; }
  bool& autoCtrl() { return this->autoCtrl_; }
  void autoCtrl(bool _val_) { this->autoCtrl_ = _val_; }
  bool clamped() const { return this->clamped_; }
  bool& clamped() { return this->clamped_; }
  void clamped(bool _val_) { this->clamped_ = _val_; }

  bool operator==(const PIDControls& _other) const
  {
    (void) _other;
    return channel_ == _other.channel_ &&
      setpoint_ == _other.setpoint_ &&
      manualOP_ == _other.manualOP_ &&
      autoCtrl_ == _other.autoCtrl_ &&
      clamped_ == _other.clamped_;
  }

  bool operator!=(const PIDControls& _other) const
  {
    return !(*this == _other);
  }

};

class PIDState
{
private:
 uint32_t machineID3_ = 0;
 std::array<::networkDataStructures::PIDIO, 16> pidIO_ = { };
 std::array<::networkDataStructures::PIDCoeff, 16> pidCoeffs_ = { };
 std::array<::networkDataStructures::PIDControls, 16> pidControls_ = { };

public:
  PIDState() = default;

  explicit PIDState(
    uint32_t machineID3,
    const std::array<::networkDataStructures::PIDIO, 16>& pidIO,
    const std::array<::networkDataStructures::PIDCoeff, 16>& pidCoeffs,
    const std::array<::networkDataStructures::PIDControls, 16>& pidControls) :
    machineID3_(machineID3),
    pidIO_(pidIO),
    pidCoeffs_(pidCoeffs),
    pidControls_(pidControls) { }

  uint32_t machineID3() const { return this->machineID3_; }
  uint32_t& machineID3() { return this->machineID3_; }
  void machineID3(uint32_t _val_) { this->machineID3_ = _val_; }
  const std::array<::networkDataStructures::PIDIO, 16>& pidIO() const { return this->pidIO_; }
  std::array<::networkDataStructures::PIDIO, 16>& pidIO() { return this->pidIO_; }
  void pidIO(const std::array<::networkDataStructures::PIDIO, 16>& _val_) { this->pidIO_ = _val_; }
  void pidIO(std::array<::networkDataStructures::PIDIO, 16>&& _val_) { this->pidIO_ = std::move(_val_); }
  const std::array<::networkDataStructures::PIDCoeff, 16>& pidCoeffs() const { return this->pidCoeffs_; }
  std::array<::networkDataStructures::PIDCoeff, 16>& pidCoeffs() { return this->pidCoeffs_; }
  void pidCoeffs(const std::array<::networkDataStructures::PIDCoeff, 16>& _val_) { this->pidCoeffs_ = _val_; }
  void pidCoeffs(std::array<::networkDataStructures::PIDCoeff, 16>&& _val_) { this->pidCoeffs_ = std::move(_val_); }
  const std::array<::networkDataStructures::PIDControls, 16>& pidControls() const { return this->pidControls_; }
  std::array<::networkDataStructures::PIDControls, 16>& pidControls() { return this->pidControls_; }
  void pidControls(const std::array<::networkDataStructures::PIDControls, 16>& _val_) { this->pidControls_ = _val_; }
  void pidControls(std::array<::networkDataStructures::PIDControls, 16>&& _val_) { this->pidControls_ = std::move(_val_); }

  bool operator==(const PIDState& _other) const
  {
    (void) _other;
    return machineID3_ == _other.machineID3_ &&
      pidIO_ == _other.pidIO_ &&
      pidCoeffs_ == _other.pidCoeffs_ &&
      pidControls_ == _other.pidControls_;
  }

  bool operator!=(const PIDState& _other) const
  {
    return !(*this == _other);
  }

};

}

#include "dds/topic/TopicTraits.hpp"
#include "org/eclipse/cyclonedds/topic/datatopic.hpp"

namespace org {
namespace eclipse {
namespace cyclonedds {
namespace topic {

template <> constexpr const char* TopicTraits<::networkDataStructures::Msg>::getTypeName()
{
  return "networkDataStructures::Msg";
}

template <> constexpr bool TopicTraits<::networkDataStructures::Msg>::isSelfContained()
{
  return false;
}

#ifdef DDSCXX_HAS_TYPELIB
template<> constexpr unsigned int TopicTraits<::networkDataStructures::Msg>::type_map_blob_sz() { return 254; }
template<> constexpr unsigned int TopicTraits<::networkDataStructures::Msg>::type_info_blob_sz() { return 100; }
template<> inline const uint8_t * TopicTraits<::networkDataStructures::Msg>::type_map_blob() {
  alignas(4) static const uint8_t blob[] = {
 0x4c,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0xf1,  0x6e,  0x42,  0x14,  0x9e,  0xb1,  0x41,  0xa0, 
 0xd7,  0x25,  0x94,  0xc6,  0x50,  0xd7,  0x3c,  0x00,  0x34,  0x00,  0x00,  0x00,  0xf1,  0x51,  0x01,  0x00, 
 0x01,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x24,  0x00,  0x00,  0x00,  0x02,  0x00,  0x00,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x31,  0x00,  0x04,  0x58,  0x5c,  0x95,  0x70,  0x00, 
 0x0c,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x70,  0x00,  0x78,  0xe7,  0x31,  0x02, 
 0x82,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0xf2,  0xfe,  0xd7,  0x86,  0xd3,  0x05,  0xda,  0x03, 
 0xfb,  0xdc,  0xfe,  0x88,  0xe0,  0x12,  0x59,  0x00,  0x6a,  0x00,  0x00,  0x00,  0xf2,  0x51,  0x01,  0x00, 
 0x23,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x1b,  0x00,  0x00,  0x00,  0x6e,  0x65,  0x74,  0x77, 
 0x6f,  0x72,  0x6b,  0x44,  0x61,  0x74,  0x61,  0x53,  0x74,  0x72,  0x75,  0x63,  0x74,  0x75,  0x72,  0x65, 
 0x73,  0x3a,  0x3a,  0x4d,  0x73,  0x67,  0x00,  0x00,  0x3a,  0x00,  0x00,  0x00,  0x02,  0x00,  0x00,  0x00, 
 0x15,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x31,  0x00,  0x04,  0x00,  0x07,  0x00,  0x00,  0x00, 
 0x75,  0x73,  0x65,  0x72,  0x49,  0x44,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x16,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x70,  0x00,  0x08,  0x00,  0x00,  0x00,  0x6d,  0x65,  0x73,  0x73, 
 0x61,  0x67,  0x65,  0x00,  0x00,  0x00,  0x00,  0x00,  0x22,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00, 
 0xf2,  0xfe,  0xd7,  0x86,  0xd3,  0x05,  0xda,  0x03,  0xfb,  0xdc,  0xfe,  0x88,  0xe0,  0x12,  0x59,  0xf1, 
 0x6e,  0x42,  0x14,  0x9e,  0xb1,  0x41,  0xa0,  0xd7,  0x25,  0x94,  0xc6,  0x50,  0xd7,  0x3c, };
  return blob;
}
template<> inline const uint8_t * TopicTraits<::networkDataStructures::Msg>::type_info_blob() {
  alignas(4) static const uint8_t blob[] = {
 0x60,  0x00,  0x00,  0x00,  0x01,  0x10,  0x00,  0x40,  0x28,  0x00,  0x00,  0x00,  0x24,  0x00,  0x00,  0x00, 
 0x14,  0x00,  0x00,  0x00,  0xf1,  0x6e,  0x42,  0x14,  0x9e,  0xb1,  0x41,  0xa0,  0xd7,  0x25,  0x94,  0xc6, 
 0x50,  0xd7,  0x3c,  0x00,  0x38,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00, 
 0x00,  0x00,  0x00,  0x00,  0x02,  0x10,  0x00,  0x40,  0x28,  0x00,  0x00,  0x00,  0x24,  0x00,  0x00,  0x00, 
 0x14,  0x00,  0x00,  0x00,  0xf2,  0xfe,  0xd7,  0x86,  0xd3,  0x05,  0xda,  0x03,  0xfb,  0xdc,  0xfe,  0x88, 
 0xe0,  0x12,  0x59,  0x00,  0x6e,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00, 
 0x00,  0x00,  0x00,  0x00, };
  return blob;
}
#endif //DDSCXX_HAS_TYPELIB

template <> constexpr const char* TopicTraits<::networkDataStructures::ChInfo>::getTypeName()
{
  return "networkDataStructures::ChInfo";
}

template <> constexpr bool TopicTraits<::networkDataStructures::ChInfo>::isSelfContained()
{
  return false;
}

#ifdef DDSCXX_HAS_TYPELIB
template<> constexpr unsigned int TopicTraits<::networkDataStructures::ChInfo>::type_map_blob_sz() { return 262; }
template<> constexpr unsigned int TopicTraits<::networkDataStructures::ChInfo>::type_info_blob_sz() { return 100; }
template<> inline const uint8_t * TopicTraits<::networkDataStructures::ChInfo>::type_map_blob() {
  alignas(4) static const uint8_t blob[] = {
 0x4c,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0xf1,  0x11,  0x6e,  0x8c,  0x57,  0xfd,  0xf9,  0x05, 
 0x5e,  0x97,  0xd7,  0xba,  0xcf,  0x96,  0x21,  0x00,  0x34,  0x00,  0x00,  0x00,  0xf1,  0x51,  0x01,  0x00, 
 0x01,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x24,  0x00,  0x00,  0x00,  0x02,  0x00,  0x00,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x31,  0x00,  0x07,  0x64,  0x22,  0x40,  0x8f,  0x00, 
 0x0c,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x70,  0x00,  0x37,  0xe2,  0x93,  0xe5, 
 0x8b,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0xf2,  0xb9,  0xcd,  0xa8,  0x9f,  0x06,  0x2c,  0xdb, 
 0x6a,  0x7b,  0x05,  0x1a,  0x85,  0xde,  0x20,  0x00,  0x73,  0x00,  0x00,  0x00,  0xf2,  0x51,  0x01,  0x00, 
 0x26,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x1e,  0x00,  0x00,  0x00,  0x6e,  0x65,  0x74,  0x77, 
 0x6f,  0x72,  0x6b,  0x44,  0x61,  0x74,  0x61,  0x53,  0x74,  0x72,  0x75,  0x63,  0x74,  0x75,  0x72,  0x65, 
 0x73,  0x3a,  0x3a,  0x43,  0x68,  0x49,  0x6e,  0x66,  0x6f,  0x00,  0x00,  0x00,  0x3f,  0x00,  0x00,  0x00, 
 0x02,  0x00,  0x00,  0x00,  0x18,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x31,  0x00,  0x07,  0x00, 
 0x0a,  0x00,  0x00,  0x00,  0x6d,  0x61,  0x63,  0x68,  0x69,  0x6e,  0x65,  0x49,  0x44,  0x00,  0x00,  0x00, 
 0x1b,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x70,  0x00,  0x0d,  0x00,  0x00,  0x00, 
 0x43,  0x68,  0x49,  0x6e,  0x66,  0x6f,  0x53,  0x74,  0x72,  0x69,  0x6e,  0x67,  0x00,  0x00,  0x00,  0x00, 
 0x22,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0xf2,  0xb9,  0xcd,  0xa8,  0x9f,  0x06,  0x2c,  0xdb, 
 0x6a,  0x7b,  0x05,  0x1a,  0x85,  0xde,  0x20,  0xf1,  0x11,  0x6e,  0x8c,  0x57,  0xfd,  0xf9,  0x05,  0x5e, 
 0x97,  0xd7,  0xba,  0xcf,  0x96,  0x21, };
  return blob;
}
template<> inline const uint8_t * TopicTraits<::networkDataStructures::ChInfo>::type_info_blob() {
  alignas(4) static const uint8_t blob[] = {
 0x60,  0x00,  0x00,  0x00,  0x01,  0x10,  0x00,  0x40,  0x28,  0x00,  0x00,  0x00,  0x24,  0x00,  0x00,  0x00, 
 0x14,  0x00,  0x00,  0x00,  0xf1,  0x11,  0x6e,  0x8c,  0x57,  0xfd,  0xf9,  0x05,  0x5e,  0x97,  0xd7,  0xba, 
 0xcf,  0x96,  0x21,  0x00,  0x38,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00, 
 0x00,  0x00,  0x00,  0x00,  0x02,  0x10,  0x00,  0x40,  0x28,  0x00,  0x00,  0x00,  0x24,  0x00,  0x00,  0x00, 
 0x14,  0x00,  0x00,  0x00,  0xf2,  0xb9,  0xcd,  0xa8,  0x9f,  0x06,  0x2c,  0xdb,  0x6a,  0x7b,  0x05,  0x1a, 
 0x85,  0xde,  0x20,  0x00,  0x77,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00, 
 0x00,  0x00,  0x00,  0x00, };
  return blob;
}
#endif //DDSCXX_HAS_TYPELIB

template <> constexpr const char* TopicTraits<::networkDataStructures::BundleStruct>::getTypeName()
{
  return "networkDataStructures::BundleStruct";
}

#ifdef DDSCXX_HAS_TYPELIB
template<> constexpr unsigned int TopicTraits<::networkDataStructures::BundleStruct>::type_map_blob_sz() { return 538; }
template<> constexpr unsigned int TopicTraits<::networkDataStructures::BundleStruct>::type_info_blob_sz() { return 100; }
template<> inline const uint8_t * TopicTraits<::networkDataStructures::BundleStruct>::type_map_blob() {
  alignas(4) static const uint8_t blob[] = {
 0xba,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0xf1,  0x7b,  0xcc,  0xd1,  0x8b,  0x61,  0xa1,  0xcd, 
 0x3b,  0x27,  0xa0,  0xf4,  0xfd,  0x02,  0xab,  0x00,  0xa2,  0x00,  0x00,  0x00,  0xf1,  0x51,  0x01,  0x00, 
 0x01,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x92,  0x00,  0x00,  0x00,  0x06,  0x00,  0x00,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x31,  0x00,  0x07,  0x64,  0x22,  0x40,  0x8f,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x08,  0x6f,  0x01,  0x2e,  0xa8,  0x00, 
 0x16,  0x00,  0x00,  0x00,  0x02,  0x00,  0x00,  0x00,  0x01,  0x00,  0x90,  0xf3,  0x01,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x00,  0x00,  0x08,  0x0a,  0x6b,  0x01,  0x19,  0x32,  0x00,  0x00,  0x16,  0x00,  0x00,  0x00, 
 0x03,  0x00,  0x00,  0x00,  0x01,  0x00,  0x90,  0xf3,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00, 
 0x08,  0x0a,  0xeb,  0xb2,  0x6a,  0x7b,  0x00,  0x00,  0x16,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x90,  0xf3,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x0c,  0x01,  0xa0,  0x15, 
 0x5c,  0xe5,  0x00,  0x00,  0x16,  0x00,  0x00,  0x00,  0x05,  0x00,  0x00,  0x00,  0x01,  0x00,  0x90,  0xf3, 
 0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x18,  0x0a,  0xb1,  0xb3,  0xa1,  0xdd,  0x00,  0x00, 
 0x2d,  0x01,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0xf2,  0xec,  0xbc,  0x28,  0x5f,  0xfe,  0xf6,  0xd4, 
 0x25,  0xf1,  0x63,  0xe7,  0x5c,  0xf6,  0x99,  0x00,  0x15,  0x01,  0x00,  0x00,  0xf2,  0x51,  0x01,  0x00, 
 0x2c,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x24,  0x00,  0x00,  0x00,  0x6e,  0x65,  0x74,  0x77, 
 0x6f,  0x72,  0x6b,  0x44,  0x61,  0x74,  0x61,  0x53,  0x74,  0x72,  0x75,  0x63,  0x74,  0x75,  0x72,  0x65, 
 0x73,  0x3a,  0x3a,  0x42,  0x75,  0x6e,  0x64,  0x6c,  0x65,  0x53,  0x74,  0x72,  0x75,  0x63,  0x74,  0x00, 
 0xdd,  0x00,  0x00,  0x00,  0x06,  0x00,  0x00,  0x00,  0x18,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 
 0x31,  0x00,  0x07,  0x00,  0x0a,  0x00,  0x00,  0x00,  0x6d,  0x61,  0x63,  0x68,  0x69,  0x6e,  0x65,  0x49, 
 0x44,  0x00,  0x00,  0x00,  0x18,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x08,  0x00, 
 0x0a,  0x00,  0x00,  0x00,  0x69,  0x74,  0x65,  0x72,  0x61,  0x74,  0x69,  0x6f,  0x6e,  0x00,  0x00,  0x00, 
 0x23,  0x00,  0x00,  0x00,  0x02,  0x00,  0x00,  0x00,  0x01,  0x00,  0x90,  0xf3,  0x01,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x00,  0x00,  0x08,  0x0a,  0x00,  0x00,  0x09,  0x00,  0x00,  0x00,  0x61,  0x69,  0x42,  0x75, 
 0x6e,  0x64,  0x6c,  0x65,  0x00,  0x00,  0x00,  0x00,  0x23,  0x00,  0x00,  0x00,  0x03,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x90,  0xf3,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x08,  0x0a,  0x00,  0x00, 
 0x09,  0x00,  0x00,  0x00,  0x61,  0x6f,  0x42,  0x75,  0x6e,  0x64,  0x6c,  0x65,  0x00,  0x00,  0x00,  0x00, 
 0x23,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00,  0x01,  0x00,  0x90,  0xf3,  0x01,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x00,  0x00,  0x0c,  0x01,  0x00,  0x00,  0x09,  0x00,  0x00,  0x00,  0x72,  0x6f,  0x42,  0x75, 
 0x6e,  0x64,  0x6c,  0x65,  0x00,  0x00,  0x00,  0x00,  0x25,  0x00,  0x00,  0x00,  0x05,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x90,  0xf3,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x18,  0x0a,  0x00,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x63,  0x61,  0x6c,  0x63,  0x42,  0x75,  0x6e,  0x64,  0x6c,  0x65,  0x00,  0x00, 
 0x00,  0x00,  0x00,  0x00,  0x22,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0xf2,  0xec,  0xbc,  0x28, 
 0x5f,  0xfe,  0xf6,  0xd4,  0x25,  0xf1,  0x63,  0xe7,  0x5c,  0xf6,  0x99,  0xf1,  0x7b,  0xcc,  0xd1,  0x8b, 
 0x61,  0xa1,  0xcd,  0x3b,  0x27,  0xa0,  0xf4,  0xfd,  0x02,  0xab, };
  return blob;
}
template<> inline const uint8_t * TopicTraits<::networkDataStructures::BundleStruct>::type_info_blob() {
  alignas(4) static const uint8_t blob[] = {
 0x60,  0x00,  0x00,  0x00,  0x01,  0x10,  0x00,  0x40,  0x28,  0x00,  0x00,  0x00,  0x24,  0x00,  0x00,  0x00, 
 0x14,  0x00,  0x00,  0x00,  0xf1,  0x7b,  0xcc,  0xd1,  0x8b,  0x61,  0xa1,  0xcd,  0x3b,  0x27,  0xa0,  0xf4, 
 0xfd,  0x02,  0xab,  0x00,  0xa6,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00, 
 0x00,  0x00,  0x00,  0x00,  0x02,  0x10,  0x00,  0x40,  0x28,  0x00,  0x00,  0x00,  0x24,  0x00,  0x00,  0x00, 
 0x14,  0x00,  0x00,  0x00,  0xf2,  0xec,  0xbc,  0x28,  0x5f,  0xfe,  0xf6,  0xd4,  0x25,  0xf1,  0x63,  0xe7, 
 0x5c,  0xf6,  0x99,  0x00,  0x19,  0x01,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00, 
 0x00,  0x00,  0x00,  0x00, };
  return blob;
}
#endif //DDSCXX_HAS_TYPELIB

template <> constexpr const char* TopicTraits<::networkDataStructures::PIDIO>::getTypeName()
{
  return "networkDataStructures::PIDIO";
}

template <> constexpr bool TopicTraits<::networkDataStructures::PIDIO>::isKeyless()
{
  return true;
}

#ifdef DDSCXX_HAS_TYPELIB
template<> constexpr unsigned int TopicTraits<::networkDataStructures::PIDIO>::type_map_blob_sz() { return 374; }
template<> constexpr unsigned int TopicTraits<::networkDataStructures::PIDIO>::type_info_blob_sz() { return 100; }
template<> inline const uint8_t * TopicTraits<::networkDataStructures::PIDIO>::type_map_blob() {
  alignas(4) static const uint8_t blob[] = {
 0x7b,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0xf1,  0xcd,  0x4b,  0x25,  0xd5,  0x15,  0xa8,  0xe3, 
 0x33,  0xe4,  0x3b,  0x6c,  0x0f,  0x4f,  0x4b,  0x00,  0x63,  0x00,  0x00,  0x00,  0xf1,  0x51,  0x01,  0x00, 
 0x01,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x53,  0x00,  0x00,  0x00,  0x05,  0x00,  0x00,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x01,  0x00,  0x07,  0xc4,  0x85,  0xd2,  0xed,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0xa5,  0x65,  0x15,  0x3d,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x02,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x67,  0x47,  0x69,  0xe3,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x03,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x74,  0x57,  0xcd,  0xd1,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0xd6,  0xec,  0x40,  0xe5,  0x00, 
 0xcc,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0xf2,  0xec,  0x0c,  0x1b,  0xc7,  0x3b,  0x41,  0x87, 
 0x58,  0x4c,  0xdf,  0x4d,  0x68,  0x6f,  0x81,  0x00,  0xb4,  0x00,  0x00,  0x00,  0xf2,  0x51,  0x01,  0x00, 
 0x25,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x1d,  0x00,  0x00,  0x00,  0x6e,  0x65,  0x74,  0x77, 
 0x6f,  0x72,  0x6b,  0x44,  0x61,  0x74,  0x61,  0x53,  0x74,  0x72,  0x75,  0x63,  0x74,  0x75,  0x72,  0x65, 
 0x73,  0x3a,  0x3a,  0x50,  0x49,  0x44,  0x49,  0x4f,  0x00,  0x00,  0x00,  0x00,  0x80,  0x00,  0x00,  0x00, 
 0x05,  0x00,  0x00,  0x00,  0x16,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x01,  0x00,  0x07,  0x00, 
 0x08,  0x00,  0x00,  0x00,  0x63,  0x68,  0x61,  0x6e,  0x6e,  0x65,  0x6c,  0x00,  0x00,  0x00,  0x00,  0x00, 
 0x11,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x00,  0x03,  0x00,  0x00,  0x00, 
 0x50,  0x56,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x11,  0x00,  0x00,  0x00,  0x02,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0x00,  0x03,  0x00,  0x00,  0x00,  0x53,  0x50,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 
 0x11,  0x00,  0x00,  0x00,  0x03,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x00,  0x03,  0x00,  0x00,  0x00, 
 0x4f,  0x50,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x14,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0x00,  0x06,  0x00,  0x00,  0x00,  0x6d,  0x61,  0x6e,  0x4f,  0x50,  0x00,  0x00,  0x00, 
 0x22,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0xf2,  0xec,  0x0c,  0x1b,  0xc7,  0x3b,  0x41,  0x87, 
 0x58,  0x4c,  0xdf,  0x4d,  0x68,  0x6f,  0x81,  0xf1,  0xcd,  0x4b,  0x25,  0xd5,  0x15,  0xa8,  0xe3,  0x33, 
 0xe4,  0x3b,  0x6c,  0x0f,  0x4f,  0x4b, };
  return blob;
}
template<> inline const uint8_t * TopicTraits<::networkDataStructures::PIDIO>::type_info_blob() {
  alignas(4) static const uint8_t blob[] = {
 0x60,  0x00,  0x00,  0x00,  0x01,  0x10,  0x00,  0x40,  0x28,  0x00,  0x00,  0x00,  0x24,  0x00,  0x00,  0x00, 
 0x14,  0x00,  0x00,  0x00,  0xf1,  0xcd,  0x4b,  0x25,  0xd5,  0x15,  0xa8,  0xe3,  0x33,  0xe4,  0x3b,  0x6c, 
 0x0f,  0x4f,  0x4b,  0x00,  0x67,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00, 
 0x00,  0x00,  0x00,  0x00,  0x02,  0x10,  0x00,  0x40,  0x28,  0x00,  0x00,  0x00,  0x24,  0x00,  0x00,  0x00, 
 0x14,  0x00,  0x00,  0x00,  0xf2,  0xec,  0x0c,  0x1b,  0xc7,  0x3b,  0x41,  0x87,  0x58,  0x4c,  0xdf,  0x4d, 
 0x68,  0x6f,  0x81,  0x00,  0xb8,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00, 
 0x00,  0x00,  0x00,  0x00, };
  return blob;
}
#endif //DDSCXX_HAS_TYPELIB

template <> constexpr const char* TopicTraits<::networkDataStructures::PIDCoeff>::getTypeName()
{
  return "networkDataStructures::PIDCoeff";
}

template <> constexpr bool TopicTraits<::networkDataStructures::PIDCoeff>::isSelfContained()
{
  return false;
}

template <> constexpr bool TopicTraits<::networkDataStructures::PIDCoeff>::isKeyless()
{
  return true;
}

#ifdef DDSCXX_HAS_TYPELIB
template<> constexpr unsigned int TopicTraits<::networkDataStructures::PIDCoeff>::type_map_blob_sz() { return 890; }
template<> constexpr unsigned int TopicTraits<::networkDataStructures::PIDCoeff>::type_info_blob_sz() { return 100; }
template<> inline const uint8_t * TopicTraits<::networkDataStructures::PIDCoeff>::type_map_blob() {
  alignas(4) static const uint8_t blob[] = {
 0x2b,  0x01,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0xf1,  0x3a,  0x77,  0xbc,  0x46,  0x49,  0x10,  0x6c, 
 0x39,  0x42,  0x8e,  0xa3,  0x31,  0x4d,  0xd5,  0x00,  0x13,  0x01,  0x00,  0x00,  0xf1,  0x51,  0x01,  0x00, 
 0x01,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x03,  0x01,  0x00,  0x00,  0x10,  0x00,  0x00,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x01,  0x00,  0x07,  0xc4,  0x85,  0xd2,  0xed,  0x00, 
 0x0c,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x70,  0x00,  0xdc,  0x04,  0xbb,  0x7e, 
 0x0b,  0x00,  0x00,  0x00,  0x02,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x31,  0xf3,  0xf3,  0x13,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x03,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x0d,  0xff,  0xd4,  0x72,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x64,  0xfa,  0x0b,  0x71,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x05,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x16,  0x03,  0xf7,  0x9f,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x06,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0xa9,  0xe8,  0xde,  0x04,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x07,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x79,  0x39,  0x6b,  0xaf,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x08,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x58,  0xc6,  0x86,  0xaf,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x09,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0xcf,  0x8f,  0x25,  0x60,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x0a,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0xbc,  0x60,  0x18,  0xf5,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x0b,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x3e,  0x4c,  0x76,  0x97,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x0c,  0x00,  0x00,  0x00,  0x01,  0x00,  0x07,  0x8a,  0xdd,  0x26,  0x5f,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x0d,  0x00,  0x00,  0x00,  0x01,  0x00,  0x07,  0x37,  0x8c,  0xb6,  0x17,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x0e,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x44,  0x7d,  0xa4,  0xee,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x0f,  0x00,  0x00,  0x00,  0x01,  0x00,  0x07,  0xa4,  0x6c,  0x8c,  0xb6,  0x00, 
 0x20,  0x02,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0xf2,  0x2e,  0x4a,  0x53,  0x67,  0xf7,  0xce,  0x3e, 
 0xfb,  0x02,  0x3c,  0x87,  0xd0,  0x09,  0x3e,  0x00,  0x08,  0x02,  0x00,  0x00,  0xf2,  0x51,  0x01,  0x00, 
 0x28,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x20,  0x00,  0x00,  0x00,  0x6e,  0x65,  0x74,  0x77, 
 0x6f,  0x72,  0x6b,  0x44,  0x61,  0x74,  0x61,  0x53,  0x74,  0x72,  0x75,  0x63,  0x74,  0x75,  0x72,  0x65, 
 0x73,  0x3a,  0x3a,  0x50,  0x49,  0x44,  0x43,  0x6f,  0x65,  0x66,  0x66,  0x00,  0xd4,  0x01,  0x00,  0x00, 
 0x10,  0x00,  0x00,  0x00,  0x16,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x01,  0x00,  0x07,  0x00, 
 0x08,  0x00,  0x00,  0x00,  0x63,  0x68,  0x61,  0x6e,  0x6e,  0x65,  0x6c,  0x00,  0x00,  0x00,  0x00,  0x00, 
 0x1a,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x70,  0x00,  0x0c,  0x00,  0x00,  0x00, 
 0x63,  0x6f,  0x6e,  0x74,  0x72,  0x6f,  0x6c,  0x4e,  0x61,  0x6d,  0x65,  0x00,  0x00,  0x00,  0x00,  0x00, 
 0x11,  0x00,  0x00,  0x00,  0x02,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x00,  0x03,  0x00,  0x00,  0x00, 
 0x6b,  0x50,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x11,  0x00,  0x00,  0x00,  0x03,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0x00,  0x03,  0x00,  0x00,  0x00,  0x6b,  0x49,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 
 0x11,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x00,  0x03,  0x00,  0x00,  0x00, 
 0x6b,  0x44,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x13,  0x00,  0x00,  0x00,  0x05,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0x00,  0x05,  0x00,  0x00,  0x00,  0x62,  0x69,  0x61,  0x73,  0x00,  0x00,  0x00,  0x00, 
 0x18,  0x00,  0x00,  0x00,  0x06,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x00,  0x0a,  0x00,  0x00,  0x00, 
 0x6f,  0x75,  0x74,  0x70,  0x75,  0x74,  0x4d,  0x61,  0x78,  0x00,  0x00,  0x00,  0x18,  0x00,  0x00,  0x00, 
 0x07,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x00,  0x0a,  0x00,  0x00,  0x00,  0x6f,  0x75,  0x74,  0x70, 
 0x75,  0x74,  0x4d,  0x69,  0x6e,  0x00,  0x00,  0x00,  0x18,  0x00,  0x00,  0x00,  0x08,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0x00,  0x0a,  0x00,  0x00,  0x00,  0x77,  0x69,  0x6e,  0x64,  0x75,  0x70,  0x4d,  0x61, 
 0x78,  0x00,  0x00,  0x00,  0x18,  0x00,  0x00,  0x00,  0x09,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x00, 
 0x0a,  0x00,  0x00,  0x00,  0x77,  0x69,  0x6e,  0x64,  0x75,  0x70,  0x4d,  0x69,  0x6e,  0x00,  0x00,  0x00, 
 0x1a,  0x00,  0x00,  0x00,  0x0a,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x00,  0x0c,  0x00,  0x00,  0x00, 
 0x64,  0x65,  0x61,  0x64,  0x62,  0x61,  0x6e,  0x64,  0x4d,  0x61,  0x78,  0x00,  0x00,  0x00,  0x00,  0x00, 
 0x1a,  0x00,  0x00,  0x00,  0x0b,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x00,  0x0c,  0x00,  0x00,  0x00, 
 0x64,  0x65,  0x61,  0x64,  0x62,  0x61,  0x6e,  0x64,  0x4d,  0x69,  0x6e,  0x00,  0x00,  0x00,  0x00,  0x00, 
 0x17,  0x00,  0x00,  0x00,  0x0c,  0x00,  0x00,  0x00,  0x01,  0x00,  0x07,  0x00,  0x09,  0x00,  0x00,  0x00, 
 0x69,  0x6e,  0x70,  0x75,  0x74,  0x4d,  0x61,  0x70,  0x00,  0x00,  0x00,  0x00,  0x18,  0x00,  0x00,  0x00, 
 0x0d,  0x00,  0x00,  0x00,  0x01,  0x00,  0x07,  0x00,  0x0a,  0x00,  0x00,  0x00,  0x6f,  0x75,  0x74,  0x70, 
 0x75,  0x74,  0x4d,  0x61,  0x70,  0x00,  0x00,  0x00,  0x1e,  0x00,  0x00,  0x00,  0x0e,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0x00,  0x10,  0x00,  0x00,  0x00,  0x76,  0x6f,  0x6c,  0x74,  0x73,  0x43,  0x6f,  0x6e, 
 0x76,  0x65,  0x72,  0x73,  0x69,  0x6f,  0x6e,  0x00,  0x00,  0x00,  0x00,  0x00,  0x24,  0x00,  0x00,  0x00, 
 0x0f,  0x00,  0x00,  0x00,  0x01,  0x00,  0x07,  0x00,  0x16,  0x00,  0x00,  0x00,  0x63,  0x6f,  0x6e,  0x74, 
 0x72,  0x6f,  0x6c,  0x55,  0x70,  0x64,  0x61,  0x74,  0x65,  0x53,  0x65,  0x6c,  0x65,  0x63,  0x74,  0x6f, 
 0x72,  0x00,  0x00,  0x00,  0x22,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0xf2,  0x2e,  0x4a,  0x53, 
 0x67,  0xf7,  0xce,  0x3e,  0xfb,  0x02,  0x3c,  0x87,  0xd0,  0x09,  0x3e,  0xf1,  0x3a,  0x77,  0xbc,  0x46, 
 0x49,  0x10,  0x6c,  0x39,  0x42,  0x8e,  0xa3,  0x31,  0x4d,  0xd5, };
  return blob;
}
template<> inline const uint8_t * TopicTraits<::networkDataStructures::PIDCoeff>::type_info_blob() {
  alignas(4) static const uint8_t blob[] = {
 0x60,  0x00,  0x00,  0x00,  0x01,  0x10,  0x00,  0x40,  0x28,  0x00,  0x00,  0x00,  0x24,  0x00,  0x00,  0x00, 
 0x14,  0x00,  0x00,  0x00,  0xf1,  0x3a,  0x77,  0xbc,  0x46,  0x49,  0x10,  0x6c,  0x39,  0x42,  0x8e,  0xa3, 
 0x31,  0x4d,  0xd5,  0x00,  0x17,  0x01,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00, 
 0x00,  0x00,  0x00,  0x00,  0x02,  0x10,  0x00,  0x40,  0x28,  0x00,  0x00,  0x00,  0x24,  0x00,  0x00,  0x00, 
 0x14,  0x00,  0x00,  0x00,  0xf2,  0x2e,  0x4a,  0x53,  0x67,  0xf7,  0xce,  0x3e,  0xfb,  0x02,  0x3c,  0x87, 
 0xd0,  0x09,  0x3e,  0x00,  0x0c,  0x02,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00, 
 0x00,  0x00,  0x00,  0x00, };
  return blob;
}
#endif //DDSCXX_HAS_TYPELIB

template <> constexpr const char* TopicTraits<::networkDataStructures::PIDControls>::getTypeName()
{
  return "networkDataStructures::PIDControls";
}

template <> constexpr bool TopicTraits<::networkDataStructures::PIDControls>::isKeyless()
{
  return true;
}

#ifdef DDSCXX_HAS_TYPELIB
template<> constexpr unsigned int TopicTraits<::networkDataStructures::PIDControls>::type_map_blob_sz() { return 394; }
template<> constexpr unsigned int TopicTraits<::networkDataStructures::PIDControls>::type_info_blob_sz() { return 100; }
template<> inline const uint8_t * TopicTraits<::networkDataStructures::PIDControls>::type_map_blob() {
  alignas(4) static const uint8_t blob[] = {
 0x7b,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0xf1,  0xd0,  0xd7,  0x1d,  0x20,  0x6d,  0xed,  0x26, 
 0xc7,  0xba,  0xe9,  0x95,  0x16,  0xac,  0x79,  0x00,  0x63,  0x00,  0x00,  0x00,  0xf1,  0x51,  0x01,  0x00, 
 0x01,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x53,  0x00,  0x00,  0x00,  0x05,  0x00,  0x00,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x01,  0x00,  0x07,  0xc4,  0x85,  0xd2,  0xed,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x2c,  0xda,  0x10,  0x16,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x02,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0xa9,  0xff,  0xcb,  0xf3,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x03,  0x00,  0x00,  0x00,  0x01,  0x00,  0x01,  0x8e,  0x0d,  0xfc,  0xcf,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00,  0x01,  0x00,  0x01,  0x48,  0xd7,  0xd3,  0xc7,  0x00, 
 0xde,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0xf2,  0xc7,  0x42,  0xce,  0x52,  0xcf,  0xa6,  0xa0, 
 0x84,  0xb4,  0xba,  0x8f,  0x63,  0xd8,  0xb0,  0x00,  0xc6,  0x00,  0x00,  0x00,  0xf2,  0x51,  0x01,  0x00, 
 0x2b,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x23,  0x00,  0x00,  0x00,  0x6e,  0x65,  0x74,  0x77, 
 0x6f,  0x72,  0x6b,  0x44,  0x61,  0x74,  0x61,  0x53,  0x74,  0x72,  0x75,  0x63,  0x74,  0x75,  0x72,  0x65, 
 0x73,  0x3a,  0x3a,  0x50,  0x49,  0x44,  0x43,  0x6f,  0x6e,  0x74,  0x72,  0x6f,  0x6c,  0x73,  0x00,  0x00, 
 0x8e,  0x00,  0x00,  0x00,  0x05,  0x00,  0x00,  0x00,  0x16,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x07,  0x00,  0x08,  0x00,  0x00,  0x00,  0x63,  0x68,  0x61,  0x6e,  0x6e,  0x65,  0x6c,  0x00, 
 0x00,  0x00,  0x00,  0x00,  0x17,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x00, 
 0x09,  0x00,  0x00,  0x00,  0x73,  0x65,  0x74,  0x70,  0x6f,  0x69,  0x6e,  0x74,  0x00,  0x00,  0x00,  0x00, 
 0x17,  0x00,  0x00,  0x00,  0x02,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x00,  0x09,  0x00,  0x00,  0x00, 
 0x6d,  0x61,  0x6e,  0x75,  0x61,  0x6c,  0x4f,  0x50,  0x00,  0x00,  0x00,  0x00,  0x17,  0x00,  0x00,  0x00, 
 0x03,  0x00,  0x00,  0x00,  0x01,  0x00,  0x01,  0x00,  0x09,  0x00,  0x00,  0x00,  0x61,  0x75,  0x74,  0x6f, 
 0x43,  0x74,  0x72,  0x6c,  0x00,  0x00,  0x00,  0x00,  0x16,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x01,  0x00,  0x08,  0x00,  0x00,  0x00,  0x63,  0x6c,  0x61,  0x6d,  0x70,  0x65,  0x64,  0x00, 
 0x00,  0x00,  0x00,  0x00,  0x22,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0xf2,  0xc7,  0x42,  0xce, 
 0x52,  0xcf,  0xa6,  0xa0,  0x84,  0xb4,  0xba,  0x8f,  0x63,  0xd8,  0xb0,  0xf1,  0xd0,  0xd7,  0x1d,  0x20, 
 0x6d,  0xed,  0x26,  0xc7,  0xba,  0xe9,  0x95,  0x16,  0xac,  0x79, };
  return blob;
}
template<> inline const uint8_t * TopicTraits<::networkDataStructures::PIDControls>::type_info_blob() {
  alignas(4) static const uint8_t blob[] = {
 0x60,  0x00,  0x00,  0x00,  0x01,  0x10,  0x00,  0x40,  0x28,  0x00,  0x00,  0x00,  0x24,  0x00,  0x00,  0x00, 
 0x14,  0x00,  0x00,  0x00,  0xf1,  0xd0,  0xd7,  0x1d,  0x20,  0x6d,  0xed,  0x26,  0xc7,  0xba,  0xe9,  0x95, 
 0x16,  0xac,  0x79,  0x00,  0x67,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00, 
 0x00,  0x00,  0x00,  0x00,  0x02,  0x10,  0x00,  0x40,  0x28,  0x00,  0x00,  0x00,  0x24,  0x00,  0x00,  0x00, 
 0x14,  0x00,  0x00,  0x00,  0xf2,  0xc7,  0x42,  0xce,  0x52,  0xcf,  0xa6,  0xa0,  0x84,  0xb4,  0xba,  0x8f, 
 0x63,  0xd8,  0xb0,  0x00,  0xca,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00, 
 0x00,  0x00,  0x00,  0x00, };
  return blob;
}
#endif //DDSCXX_HAS_TYPELIB

template <> constexpr const char* TopicTraits<::networkDataStructures::PIDState>::getTypeName()
{
  return "networkDataStructures::PIDState";
}

template <> constexpr bool TopicTraits<::networkDataStructures::PIDState>::isSelfContained()
{
  return false;
}

#ifdef DDSCXX_HAS_TYPELIB
template<> constexpr unsigned int TopicTraits<::networkDataStructures::PIDState>::type_map_blob_sz() { return 2080; }
template<> constexpr unsigned int TopicTraits<::networkDataStructures::PIDState>::type_info_blob_sz() { return 244; }
template<> inline const uint8_t * TopicTraits<::networkDataStructures::PIDState>::type_map_blob() {
  alignas(4) static const uint8_t blob[] = {
 0xcb,  0x02,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00,  0xf1,  0x40,  0x96,  0xe8,  0x29,  0x82,  0xa8,  0x48, 
 0x29,  0xc1,  0x2e,  0xbb,  0x1a,  0x08,  0x6c,  0x00,  0x9c,  0x00,  0x00,  0x00,  0xf1,  0x51,  0x01,  0x00, 
 0x01,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x8c,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x31,  0x00,  0x07,  0x58,  0x8f,  0xa6,  0x68,  0x00, 
 0x24,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x90,  0xf1,  0x01,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x00,  0x00,  0x10,  0xf1,  0xcd,  0x4b,  0x25,  0xd5,  0x15,  0xa8,  0xe3,  0x33,  0xe4,  0x3b, 
 0x6c,  0x0f,  0x4f,  0x4b,  0x1a,  0x35,  0xf8,  0x59,  0x24,  0x00,  0x00,  0x00,  0x02,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x90,  0xf1,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x10,  0xf1,  0x3a,  0x77, 
 0xbc,  0x46,  0x49,  0x10,  0x6c,  0x39,  0x42,  0x8e,  0xa3,  0x31,  0x4d,  0xd5,  0x62,  0x27,  0xff,  0xe8, 
 0x24,  0x00,  0x00,  0x00,  0x03,  0x00,  0x00,  0x00,  0x01,  0x00,  0x90,  0xf1,  0x01,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x00,  0x00,  0x10,  0xf1,  0xd0,  0xd7,  0x1d,  0x20,  0x6d,  0xed,  0x26,  0xc7,  0xba,  0xe9, 
 0x95,  0x16,  0xac,  0x79,  0x1f,  0x7d,  0xf0,  0x06,  0xf1,  0xcd,  0x4b,  0x25,  0xd5,  0x15,  0xa8,  0xe3, 
 0x33,  0xe4,  0x3b,  0x6c,  0x0f,  0x4f,  0x4b,  0x00,  0x63,  0x00,  0x00,  0x00,  0xf1,  0x51,  0x01,  0x00, 
 0x01,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x53,  0x00,  0x00,  0x00,  0x05,  0x00,  0x00,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x01,  0x00,  0x07,  0xc4,  0x85,  0xd2,  0xed,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0xa5,  0x65,  0x15,  0x3d,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x02,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x67,  0x47,  0x69,  0xe3,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x03,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x74,  0x57,  0xcd,  0xd1,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0xd6,  0xec,  0x40,  0xe5,  0xf1, 
 0x3a,  0x77,  0xbc,  0x46,  0x49,  0x10,  0x6c,  0x39,  0x42,  0x8e,  0xa3,  0x31,  0x4d,  0xd5,  0x00,  0x00, 
 0x13,  0x01,  0x00,  0x00,  0xf1,  0x51,  0x01,  0x00,  0x01,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 
 0x03,  0x01,  0x00,  0x00,  0x10,  0x00,  0x00,  0x00,  0x0b,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x07,  0xc4,  0x85,  0xd2,  0xed,  0x00,  0x0c,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x70,  0x00,  0xdc,  0x04,  0xbb,  0x7e,  0x0b,  0x00,  0x00,  0x00,  0x02,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0x31,  0xf3,  0xf3,  0x13,  0x00,  0x0b,  0x00,  0x00,  0x00,  0x03,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0x0d,  0xff,  0xd4,  0x72,  0x00,  0x0b,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0x64,  0xfa,  0x0b,  0x71,  0x00,  0x0b,  0x00,  0x00,  0x00,  0x05,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0x16,  0x03,  0xf7,  0x9f,  0x00,  0x0b,  0x00,  0x00,  0x00,  0x06,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0xa9,  0xe8,  0xde,  0x04,  0x00,  0x0b,  0x00,  0x00,  0x00,  0x07,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0x79,  0x39,  0x6b,  0xaf,  0x00,  0x0b,  0x00,  0x00,  0x00,  0x08,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0x58,  0xc6,  0x86,  0xaf,  0x00,  0x0b,  0x00,  0x00,  0x00,  0x09,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0xcf,  0x8f,  0x25,  0x60,  0x00,  0x0b,  0x00,  0x00,  0x00,  0x0a,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0xbc,  0x60,  0x18,  0xf5,  0x00,  0x0b,  0x00,  0x00,  0x00,  0x0b,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0x3e,  0x4c,  0x76,  0x97,  0x00,  0x0b,  0x00,  0x00,  0x00,  0x0c,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x07,  0x8a,  0xdd,  0x26,  0x5f,  0x00,  0x0b,  0x00,  0x00,  0x00,  0x0d,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x07,  0x37,  0x8c,  0xb6,  0x17,  0x00,  0x0b,  0x00,  0x00,  0x00,  0x0e,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0x44,  0x7d,  0xa4,  0xee,  0x00,  0x0b,  0x00,  0x00,  0x00,  0x0f,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x07,  0xa4,  0x6c,  0x8c,  0xb6,  0xf1,  0xd0,  0xd7,  0x1d,  0x20,  0x6d,  0xed,  0x26,  0xc7, 
 0xba,  0xe9,  0x95,  0x16,  0xac,  0x79,  0x00,  0x00,  0x63,  0x00,  0x00,  0x00,  0xf1,  0x51,  0x01,  0x00, 
 0x01,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x53,  0x00,  0x00,  0x00,  0x05,  0x00,  0x00,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x01,  0x00,  0x07,  0xc4,  0x85,  0xd2,  0xed,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x2c,  0xda,  0x10,  0x16,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x02,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0xa9,  0xff,  0xcb,  0xf3,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x03,  0x00,  0x00,  0x00,  0x01,  0x00,  0x01,  0x8e,  0x0d,  0xfc,  0xcf,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00,  0x01,  0x00,  0x01,  0x48,  0xd7,  0xd3,  0xc7,  0x00, 
 0xca,  0x04,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00,  0xf2,  0xe0,  0x6b,  0x1a,  0x50,  0x7c,  0xce,  0x32, 
 0x76,  0x2e,  0x33,  0xda,  0x75,  0x5e,  0xb2,  0x00,  0xf2,  0x00,  0x00,  0x00,  0xf2,  0x51,  0x01,  0x00, 
 0x28,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x20,  0x00,  0x00,  0x00,  0x6e,  0x65,  0x74,  0x77, 
 0x6f,  0x72,  0x6b,  0x44,  0x61,  0x74,  0x61,  0x53,  0x74,  0x72,  0x75,  0x63,  0x74,  0x75,  0x72,  0x65, 
 0x73,  0x3a,  0x3a,  0x50,  0x49,  0x44,  0x53,  0x74,  0x61,  0x74,  0x65,  0x00,  0xbe,  0x00,  0x00,  0x00, 
 0x04,  0x00,  0x00,  0x00,  0x19,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x31,  0x00,  0x07,  0x00, 
 0x0b,  0x00,  0x00,  0x00,  0x6d,  0x61,  0x63,  0x68,  0x69,  0x6e,  0x65,  0x49,  0x44,  0x33,  0x00,  0x00, 
 0x00,  0x00,  0x00,  0x00,  0x2c,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x90,  0xf2, 
 0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x10,  0xf2,  0xec,  0x0c,  0x1b,  0xc7,  0x3b,  0x41, 
 0x87,  0x58,  0x4c,  0xdf,  0x4d,  0x68,  0x6f,  0x81,  0x06,  0x00,  0x00,  0x00,  0x70,  0x69,  0x64,  0x49, 
 0x4f,  0x00,  0x00,  0x00,  0x30,  0x00,  0x00,  0x00,  0x02,  0x00,  0x00,  0x00,  0x01,  0x00,  0x90,  0xf2, 
 0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x10,  0xf2,  0x2e,  0x4a,  0x53,  0x67,  0xf7,  0xce, 
 0x3e,  0xfb,  0x02,  0x3c,  0x87,  0xd0,  0x09,  0x3e,  0x0a,  0x00,  0x00,  0x00,  0x70,  0x69,  0x64,  0x43, 
 0x6f,  0x65,  0x66,  0x66,  0x73,  0x00,  0x00,  0x00,  0x32,  0x00,  0x00,  0x00,  0x03,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x90,  0xf2,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x10,  0xf2,  0xc7,  0x42, 
 0xce,  0x52,  0xcf,  0xa6,  0xa0,  0x84,  0xb4,  0xba,  0x8f,  0x63,  0xd8,  0xb0,  0x0c,  0x00,  0x00,  0x00, 
 0x70,  0x69,  0x64,  0x43,  0x6f,  0x6e,  0x74,  0x72,  0x6f,  0x6c,  0x73,  0x00,  0x00,  0x00,  0xf2,  0xec, 
 0x0c,  0x1b,  0xc7,  0x3b,  0x41,  0x87,  0x58,  0x4c,  0xdf,  0x4d,  0x68,  0x6f,  0x81,  0x00,  0x00,  0x00, 
 0xb4,  0x00,  0x00,  0x00,  0xf2,  0x51,  0x01,  0x00,  0x25,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 
 0x1d,  0x00,  0x00,  0x00,  0x6e,  0x65,  0x74,  0x77,  0x6f,  0x72,  0x6b,  0x44,  0x61,  0x74,  0x61,  0x53, 
 0x74,  0x72,  0x75,  0x63,  0x74,  0x75,  0x72,  0x65,  0x73,  0x3a,  0x3a,  0x50,  0x49,  0x44,  0x49,  0x4f, 
 0x00,  0x00,  0x00,  0x00,  0x80,  0x00,  0x00,  0x00,  0x05,  0x00,  0x00,  0x00,  0x16,  0x00,  0x00,  0x00, 
 0x00,  0x00,  0x00,  0x00,  0x01,  0x00,  0x07,  0x00,  0x08,  0x00,  0x00,  0x00,  0x63,  0x68,  0x61,  0x6e, 
 0x6e,  0x65,  0x6c,  0x00,  0x00,  0x00,  0x00,  0x00,  0x11,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0x00,  0x03,  0x00,  0x00,  0x00,  0x50,  0x56,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 
 0x11,  0x00,  0x00,  0x00,  0x02,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x00,  0x03,  0x00,  0x00,  0x00, 
 0x53,  0x50,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x11,  0x00,  0x00,  0x00,  0x03,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0x00,  0x03,  0x00,  0x00,  0x00,  0x4f,  0x50,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 
 0x14,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x00,  0x06,  0x00,  0x00,  0x00, 
 0x6d,  0x61,  0x6e,  0x4f,  0x50,  0x00,  0x00,  0x00,  0xf2,  0x2e,  0x4a,  0x53,  0x67,  0xf7,  0xce,  0x3e, 
 0xfb,  0x02,  0x3c,  0x87,  0xd0,  0x09,  0x3e,  0x00,  0x08,  0x02,  0x00,  0x00,  0xf2,  0x51,  0x01,  0x00, 
 0x28,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x20,  0x00,  0x00,  0x00,  0x6e,  0x65,  0x74,  0x77, 
 0x6f,  0x72,  0x6b,  0x44,  0x61,  0x74,  0x61,  0x53,  0x74,  0x72,  0x75,  0x63,  0x74,  0x75,  0x72,  0x65, 
 0x73,  0x3a,  0x3a,  0x50,  0x49,  0x44,  0x43,  0x6f,  0x65,  0x66,  0x66,  0x00,  0xd4,  0x01,  0x00,  0x00, 
 0x10,  0x00,  0x00,  0x00,  0x16,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x01,  0x00,  0x07,  0x00, 
 0x08,  0x00,  0x00,  0x00,  0x63,  0x68,  0x61,  0x6e,  0x6e,  0x65,  0x6c,  0x00,  0x00,  0x00,  0x00,  0x00, 
 0x1a,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x70,  0x00,  0x0c,  0x00,  0x00,  0x00, 
 0x63,  0x6f,  0x6e,  0x74,  0x72,  0x6f,  0x6c,  0x4e,  0x61,  0x6d,  0x65,  0x00,  0x00,  0x00,  0x00,  0x00, 
 0x11,  0x00,  0x00,  0x00,  0x02,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x00,  0x03,  0x00,  0x00,  0x00, 
 0x6b,  0x50,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x11,  0x00,  0x00,  0x00,  0x03,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0x00,  0x03,  0x00,  0x00,  0x00,  0x6b,  0x49,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00, 
 0x11,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x00,  0x03,  0x00,  0x00,  0x00, 
 0x6b,  0x44,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x13,  0x00,  0x00,  0x00,  0x05,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0x00,  0x05,  0x00,  0x00,  0x00,  0x62,  0x69,  0x61,  0x73,  0x00,  0x00,  0x00,  0x00, 
 0x18,  0x00,  0x00,  0x00,  0x06,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x00,  0x0a,  0x00,  0x00,  0x00, 
 0x6f,  0x75,  0x74,  0x70,  0x75,  0x74,  0x4d,  0x61,  0x78,  0x00,  0x00,  0x00,  0x18,  0x00,  0x00,  0x00, 
 0x07,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x00,  0x0a,  0x00,  0x00,  0x00,  0x6f,  0x75,  0x74,  0x70, 
 0x75,  0x74,  0x4d,  0x69,  0x6e,  0x00,  0x00,  0x00,  0x18,  0x00,  0x00,  0x00,  0x08,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0x00,  0x0a,  0x00,  0x00,  0x00,  0x77,  0x69,  0x6e,  0x64,  0x75,  0x70,  0x4d,  0x61, 
 0x78,  0x00,  0x00,  0x00,  0x18,  0x00,  0x00,  0x00,  0x09,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x00, 
 0x0a,  0x00,  0x00,  0x00,  0x77,  0x69,  0x6e,  0x64,  0x75,  0x70,  0x4d,  0x69,  0x6e,  0x00,  0x00,  0x00, 
 0x1a,  0x00,  0x00,  0x00,  0x0a,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x00,  0x0c,  0x00,  0x00,  0x00, 
 0x64,  0x65,  0x61,  0x64,  0x62,  0x61,  0x6e,  0x64,  0x4d,  0x61,  0x78,  0x00,  0x00,  0x00,  0x00,  0x00, 
 0x1a,  0x00,  0x00,  0x00,  0x0b,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x00,  0x0c,  0x00,  0x00,  0x00, 
 0x64,  0x65,  0x61,  0x64,  0x62,  0x61,  0x6e,  0x64,  0x4d,  0x69,  0x6e,  0x00,  0x00,  0x00,  0x00,  0x00, 
 0x17,  0x00,  0x00,  0x00,  0x0c,  0x00,  0x00,  0x00,  0x01,  0x00,  0x07,  0x00,  0x09,  0x00,  0x00,  0x00, 
 0x69,  0x6e,  0x70,  0x75,  0x74,  0x4d,  0x61,  0x70,  0x00,  0x00,  0x00,  0x00,  0x18,  0x00,  0x00,  0x00, 
 0x0d,  0x00,  0x00,  0x00,  0x01,  0x00,  0x07,  0x00,  0x0a,  0x00,  0x00,  0x00,  0x6f,  0x75,  0x74,  0x70, 
 0x75,  0x74,  0x4d,  0x61,  0x70,  0x00,  0x00,  0x00,  0x1e,  0x00,  0x00,  0x00,  0x0e,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x0a,  0x00,  0x10,  0x00,  0x00,  0x00,  0x76,  0x6f,  0x6c,  0x74,  0x73,  0x43,  0x6f,  0x6e, 
 0x76,  0x65,  0x72,  0x73,  0x69,  0x6f,  0x6e,  0x00,  0x00,  0x00,  0x00,  0x00,  0x24,  0x00,  0x00,  0x00, 
 0x0f,  0x00,  0x00,  0x00,  0x01,  0x00,  0x07,  0x00,  0x16,  0x00,  0x00,  0x00,  0x63,  0x6f,  0x6e,  0x74, 
 0x72,  0x6f,  0x6c,  0x55,  0x70,  0x64,  0x61,  0x74,  0x65,  0x53,  0x65,  0x6c,  0x65,  0x63,  0x74,  0x6f, 
 0x72,  0x00,  0x00,  0x00,  0xf2,  0xc7,  0x42,  0xce,  0x52,  0xcf,  0xa6,  0xa0,  0x84,  0xb4,  0xba,  0x8f, 
 0x63,  0xd8,  0xb0,  0x00,  0xc6,  0x00,  0x00,  0x00,  0xf2,  0x51,  0x01,  0x00,  0x2b,  0x00,  0x00,  0x00, 
 0x00,  0x00,  0x00,  0x00,  0x23,  0x00,  0x00,  0x00,  0x6e,  0x65,  0x74,  0x77,  0x6f,  0x72,  0x6b,  0x44, 
 0x61,  0x74,  0x61,  0x53,  0x74,  0x72,  0x75,  0x63,  0x74,  0x75,  0x72,  0x65,  0x73,  0x3a,  0x3a,  0x50, 
 0x49,  0x44,  0x43,  0x6f,  0x6e,  0x74,  0x72,  0x6f,  0x6c,  0x73,  0x00,  0x00,  0x8e,  0x00,  0x00,  0x00, 
 0x05,  0x00,  0x00,  0x00,  0x16,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x01,  0x00,  0x07,  0x00, 
 0x08,  0x00,  0x00,  0x00,  0x63,  0x68,  0x61,  0x6e,  0x6e,  0x65,  0x6c,  0x00,  0x00,  0x00,  0x00,  0x00, 
 0x17,  0x00,  0x00,  0x00,  0x01,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x00,  0x09,  0x00,  0x00,  0x00, 
 0x73,  0x65,  0x74,  0x70,  0x6f,  0x69,  0x6e,  0x74,  0x00,  0x00,  0x00,  0x00,  0x17,  0x00,  0x00,  0x00, 
 0x02,  0x00,  0x00,  0x00,  0x01,  0x00,  0x0a,  0x00,  0x09,  0x00,  0x00,  0x00,  0x6d,  0x61,  0x6e,  0x75, 
 0x61,  0x6c,  0x4f,  0x50,  0x00,  0x00,  0x00,  0x00,  0x17,  0x00,  0x00,  0x00,  0x03,  0x00,  0x00,  0x00, 
 0x01,  0x00,  0x01,  0x00,  0x09,  0x00,  0x00,  0x00,  0x61,  0x75,  0x74,  0x6f,  0x43,  0x74,  0x72,  0x6c, 
 0x00,  0x00,  0x00,  0x00,  0x16,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00,  0x01,  0x00,  0x01,  0x00, 
 0x08,  0x00,  0x00,  0x00,  0x63,  0x6c,  0x61,  0x6d,  0x70,  0x65,  0x64,  0x00,  0x00,  0x00,  0x00,  0x00, 
 0x7c,  0x00,  0x00,  0x00,  0x04,  0x00,  0x00,  0x00,  0xf2,  0xe0,  0x6b,  0x1a,  0x50,  0x7c,  0xce,  0x32, 
 0x76,  0x2e,  0x33,  0xda,  0x75,  0x5e,  0xb2,  0xf1,  0x40,  0x96,  0xe8,  0x29,  0x82,  0xa8,  0x48,  0x29, 
 0xc1,  0x2e,  0xbb,  0x1a,  0x08,  0x6c,  0xf2,  0xec,  0x0c,  0x1b,  0xc7,  0x3b,  0x41,  0x87,  0x58,  0x4c, 
 0xdf,  0x4d,  0x68,  0x6f,  0x81,  0xf1,  0xcd,  0x4b,  0x25,  0xd5,  0x15,  0xa8,  0xe3,  0x33,  0xe4,  0x3b, 
 0x6c,  0x0f,  0x4f,  0x4b,  0xf2,  0x2e,  0x4a,  0x53,  0x67,  0xf7,  0xce,  0x3e,  0xfb,  0x02,  0x3c,  0x87, 
 0xd0,  0x09,  0x3e,  0xf1,  0x3a,  0x77,  0xbc,  0x46,  0x49,  0x10,  0x6c,  0x39,  0x42,  0x8e,  0xa3,  0x31, 
 0x4d,  0xd5,  0xf2,  0xc7,  0x42,  0xce,  0x52,  0xcf,  0xa6,  0xa0,  0x84,  0xb4,  0xba,  0x8f,  0x63,  0xd8, 
 0xb0,  0xf1,  0xd0,  0xd7,  0x1d,  0x20,  0x6d,  0xed,  0x26,  0xc7,  0xba,  0xe9,  0x95,  0x16,  0xac,  0x79, 
};
  return blob;
}
template<> inline const uint8_t * TopicTraits<::networkDataStructures::PIDState>::type_info_blob() {
  alignas(4) static const uint8_t blob[] = {
 0xf0,  0x00,  0x00,  0x00,  0x01,  0x10,  0x00,  0x40,  0x70,  0x00,  0x00,  0x00,  0x6c,  0x00,  0x00,  0x00, 
 0x14,  0x00,  0x00,  0x00,  0xf1,  0x40,  0x96,  0xe8,  0x29,  0x82,  0xa8,  0x48,  0x29,  0xc1,  0x2e,  0xbb, 
 0x1a,  0x08,  0x6c,  0x00,  0xa0,  0x00,  0x00,  0x00,  0x03,  0x00,  0x00,  0x00,  0x4c,  0x00,  0x00,  0x00, 
 0x03,  0x00,  0x00,  0x00,  0x14,  0x00,  0x00,  0x00,  0xf1,  0xcd,  0x4b,  0x25,  0xd5,  0x15,  0xa8,  0xe3, 
 0x33,  0xe4,  0x3b,  0x6c,  0x0f,  0x4f,  0x4b,  0x00,  0x67,  0x00,  0x00,  0x00,  0x14,  0x00,  0x00,  0x00, 
 0xf1,  0x3a,  0x77,  0xbc,  0x46,  0x49,  0x10,  0x6c,  0x39,  0x42,  0x8e,  0xa3,  0x31,  0x4d,  0xd5,  0x00, 
 0x17,  0x01,  0x00,  0x00,  0x14,  0x00,  0x00,  0x00,  0xf1,  0xd0,  0xd7,  0x1d,  0x20,  0x6d,  0xed,  0x26, 
 0xc7,  0xba,  0xe9,  0x95,  0x16,  0xac,  0x79,  0x00,  0x67,  0x00,  0x00,  0x00,  0x02,  0x10,  0x00,  0x40, 
 0x70,  0x00,  0x00,  0x00,  0x6c,  0x00,  0x00,  0x00,  0x14,  0x00,  0x00,  0x00,  0xf2,  0xe0,  0x6b,  0x1a, 
 0x50,  0x7c,  0xce,  0x32,  0x76,  0x2e,  0x33,  0xda,  0x75,  0x5e,  0xb2,  0x00,  0xf6,  0x00,  0x00,  0x00, 
 0x03,  0x00,  0x00,  0x00,  0x4c,  0x00,  0x00,  0x00,  0x03,  0x00,  0x00,  0x00,  0x14,  0x00,  0x00,  0x00, 
 0xf2,  0xec,  0x0c,  0x1b,  0xc7,  0x3b,  0x41,  0x87,  0x58,  0x4c,  0xdf,  0x4d,  0x68,  0x6f,  0x81,  0x00, 
 0xb8,  0x00,  0x00,  0x00,  0x14,  0x00,  0x00,  0x00,  0xf2,  0x2e,  0x4a,  0x53,  0x67,  0xf7,  0xce,  0x3e, 
 0xfb,  0x02,  0x3c,  0x87,  0xd0,  0x09,  0x3e,  0x00,  0x0c,  0x02,  0x00,  0x00,  0x14,  0x00,  0x00,  0x00, 
 0xf2,  0xc7,  0x42,  0xce,  0x52,  0xcf,  0xa6,  0xa0,  0x84,  0xb4,  0xba,  0x8f,  0x63,  0xd8,  0xb0,  0x00, 
 0xca,  0x00,  0x00,  0x00, };
  return blob;
}
#endif //DDSCXX_HAS_TYPELIB

} //namespace topic
} //namespace cyclonedds
} //namespace eclipse
} //namespace org

namespace dds {
namespace topic {

template <>
struct topic_type_name<::networkDataStructures::Msg>
{
    static std::string value()
    {
      return org::eclipse::cyclonedds::topic::TopicTraits<::networkDataStructures::Msg>::getTypeName();
    }
};

template <>
struct topic_type_name<::networkDataStructures::ChInfo>
{
    static std::string value()
    {
      return org::eclipse::cyclonedds::topic::TopicTraits<::networkDataStructures::ChInfo>::getTypeName();
    }
};

template <>
struct topic_type_name<::networkDataStructures::BundleStruct>
{
    static std::string value()
    {
      return org::eclipse::cyclonedds::topic::TopicTraits<::networkDataStructures::BundleStruct>::getTypeName();
    }
};

template <>
struct topic_type_name<::networkDataStructures::PIDIO>
{
    static std::string value()
    {
      return org::eclipse::cyclonedds::topic::TopicTraits<::networkDataStructures::PIDIO>::getTypeName();
    }
};

template <>
struct topic_type_name<::networkDataStructures::PIDCoeff>
{
    static std::string value()
    {
      return org::eclipse::cyclonedds::topic::TopicTraits<::networkDataStructures::PIDCoeff>::getTypeName();
    }
};

template <>
struct topic_type_name<::networkDataStructures::PIDControls>
{
    static std::string value()
    {
      return org::eclipse::cyclonedds::topic::TopicTraits<::networkDataStructures::PIDControls>::getTypeName();
    }
};

template <>
struct topic_type_name<::networkDataStructures::PIDState>
{
    static std::string value()
    {
      return org::eclipse::cyclonedds::topic::TopicTraits<::networkDataStructures::PIDState>::getTypeName();
    }
};

}
}

REGISTER_TOPIC_TYPE(::networkDataStructures::Msg)
REGISTER_TOPIC_TYPE(::networkDataStructures::ChInfo)
REGISTER_TOPIC_TYPE(::networkDataStructures::BundleStruct)
REGISTER_TOPIC_TYPE(::networkDataStructures::PIDIO)
REGISTER_TOPIC_TYPE(::networkDataStructures::PIDCoeff)
REGISTER_TOPIC_TYPE(::networkDataStructures::PIDControls)
REGISTER_TOPIC_TYPE(::networkDataStructures::PIDState)

namespace org{
namespace eclipse{
namespace cyclonedds{
namespace core{
namespace cdr{

template<>
const propvec &get_type_props<::networkDataStructures::Msg>();

namespace {
  static const volatile propvec &properties___networkDataStructures__Msg = get_type_props<::networkDataStructures::Msg>();
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool write(T& streamer, const ::networkDataStructures::Msg& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.userID()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!write_string(streamer, instance.message(), 0))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool write(S& str, const ::networkDataStructures::Msg& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::Msg>();
  str.set_mode(cdr_stream::stream_mode::write, key);
  return write(str, instance, props.data()); 
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool read(T& streamer, ::networkDataStructures::Msg& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.userID()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!read_string(streamer, instance.message(), 0))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool read(S& str, ::networkDataStructures::Msg& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::Msg>();
  str.set_mode(cdr_stream::stream_mode::read, key);
  return read(str, instance, props.data()); 
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool move(T& streamer, const ::networkDataStructures::Msg& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.userID()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!move_string(streamer, instance.message(), 0))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool move(S& str, const ::networkDataStructures::Msg& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::Msg>();
  str.set_mode(cdr_stream::stream_mode::move, key);
  return move(str, instance, props.data()); 
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool max(T& streamer, const ::networkDataStructures::Msg& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.userID()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!max_string(streamer, instance.message(), 0))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool max(S& str, const ::networkDataStructures::Msg& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::Msg>();
  str.set_mode(cdr_stream::stream_mode::max, key);
  return max(str, instance, props.data()); 
}

template<>
const propvec &get_type_props<::networkDataStructures::ChInfo>();

namespace {
  static const volatile propvec &properties___networkDataStructures__ChInfo = get_type_props<::networkDataStructures::ChInfo>();
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool write(T& streamer, const ::networkDataStructures::ChInfo& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.machineID()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!write_string(streamer, instance.ChInfoString(), 0))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool write(S& str, const ::networkDataStructures::ChInfo& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::ChInfo>();
  str.set_mode(cdr_stream::stream_mode::write, key);
  return write(str, instance, props.data()); 
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool read(T& streamer, ::networkDataStructures::ChInfo& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.machineID()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!read_string(streamer, instance.ChInfoString(), 0))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool read(S& str, ::networkDataStructures::ChInfo& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::ChInfo>();
  str.set_mode(cdr_stream::stream_mode::read, key);
  return read(str, instance, props.data()); 
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool move(T& streamer, const ::networkDataStructures::ChInfo& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.machineID()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!move_string(streamer, instance.ChInfoString(), 0))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool move(S& str, const ::networkDataStructures::ChInfo& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::ChInfo>();
  str.set_mode(cdr_stream::stream_mode::move, key);
  return move(str, instance, props.data()); 
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool max(T& streamer, const ::networkDataStructures::ChInfo& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.machineID()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!max_string(streamer, instance.ChInfoString(), 0))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool max(S& str, const ::networkDataStructures::ChInfo& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::ChInfo>();
  str.set_mode(cdr_stream::stream_mode::max, key);
  return max(str, instance, props.data()); 
}

template<>
const propvec &get_type_props<::networkDataStructures::BundleStruct>();

namespace {
  static const volatile propvec &properties___networkDataStructures__BundleStruct = get_type_props<::networkDataStructures::BundleStruct>();
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool write(T& streamer, const ::networkDataStructures::BundleStruct& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.machineID()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.iteration()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 2:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, true))
        return false;
      if (!write(streamer, instance.aiBundle()[0], instance.aiBundle().size()))
        return false;
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 3:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, true))
        return false;
      if (!write(streamer, instance.aoBundle()[0], instance.aoBundle().size()))
        return false;
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 4:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, true))
        return false;
      if (!write(streamer, instance.roBundle()[0], instance.roBundle().size()))
        return false;
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 5:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, true))
        return false;
      if (!write(streamer, instance.calcBundle()[0], instance.calcBundle().size()))
        return false;
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool write(S& str, const ::networkDataStructures::BundleStruct& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::BundleStruct>();
  str.set_mode(cdr_stream::stream_mode::write, key);
  return write(str, instance, props.data()); 
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool read(T& streamer, ::networkDataStructures::BundleStruct& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.machineID()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.iteration()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 2:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, true))
        return false;
      if (!read(streamer, instance.aiBundle()[0], instance.aiBundle().size()))
        return false;
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 3:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, true))
        return false;
      if (!read(streamer, instance.aoBundle()[0], instance.aoBundle().size()))
        return false;
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 4:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, true))
        return false;
      if (!read(streamer, instance.roBundle()[0], instance.roBundle().size()))
        return false;
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 5:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, true))
        return false;
      if (!read(streamer, instance.calcBundle()[0], instance.calcBundle().size()))
        return false;
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool read(S& str, ::networkDataStructures::BundleStruct& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::BundleStruct>();
  str.set_mode(cdr_stream::stream_mode::read, key);
  return read(str, instance, props.data()); 
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool move(T& streamer, const ::networkDataStructures::BundleStruct& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.machineID()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.iteration()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 2:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, true))
        return false;
      if (!move(streamer, instance.aiBundle()[0], instance.aiBundle().size()))
        return false;
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 3:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, true))
        return false;
      if (!move(streamer, instance.aoBundle()[0], instance.aoBundle().size()))
        return false;
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 4:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, true))
        return false;
      if (!move(streamer, instance.roBundle()[0], instance.roBundle().size()))
        return false;
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 5:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, true))
        return false;
      if (!move(streamer, instance.calcBundle()[0], instance.calcBundle().size()))
        return false;
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool move(S& str, const ::networkDataStructures::BundleStruct& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::BundleStruct>();
  str.set_mode(cdr_stream::stream_mode::move, key);
  return move(str, instance, props.data()); 
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool max(T& streamer, const ::networkDataStructures::BundleStruct& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.machineID()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.iteration()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 2:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, true))
        return false;
      if (!max(streamer, instance.aiBundle()[0], instance.aiBundle().size()))
        return false;
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 3:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, true))
        return false;
      if (!max(streamer, instance.aoBundle()[0], instance.aoBundle().size()))
        return false;
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 4:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, true))
        return false;
      if (!max(streamer, instance.roBundle()[0], instance.roBundle().size()))
        return false;
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 5:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, true))
        return false;
      if (!max(streamer, instance.calcBundle()[0], instance.calcBundle().size()))
        return false;
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool max(S& str, const ::networkDataStructures::BundleStruct& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::BundleStruct>();
  str.set_mode(cdr_stream::stream_mode::max, key);
  return max(str, instance, props.data()); 
}

template<>
const propvec &get_type_props<::networkDataStructures::PIDIO>();

namespace {
  static const volatile propvec &properties___networkDataStructures__PIDIO = get_type_props<::networkDataStructures::PIDIO>();
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool write(T& streamer, const ::networkDataStructures::PIDIO& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.channel()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.PV()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 2:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.SP()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 3:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.OP()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 4:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.manOP()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool write(S& str, const ::networkDataStructures::PIDIO& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::PIDIO>();
  str.set_mode(cdr_stream::stream_mode::write, key);
  return write(str, instance, props.data()); 
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool read(T& streamer, ::networkDataStructures::PIDIO& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.channel()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.PV()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 2:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.SP()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 3:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.OP()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 4:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.manOP()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool read(S& str, ::networkDataStructures::PIDIO& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::PIDIO>();
  str.set_mode(cdr_stream::stream_mode::read, key);
  return read(str, instance, props.data()); 
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool move(T& streamer, const ::networkDataStructures::PIDIO& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.channel()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.PV()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 2:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.SP()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 3:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.OP()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 4:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.manOP()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool move(S& str, const ::networkDataStructures::PIDIO& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::PIDIO>();
  str.set_mode(cdr_stream::stream_mode::move, key);
  return move(str, instance, props.data()); 
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool max(T& streamer, const ::networkDataStructures::PIDIO& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.channel()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.PV()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 2:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.SP()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 3:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.OP()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 4:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.manOP()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool max(S& str, const ::networkDataStructures::PIDIO& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::PIDIO>();
  str.set_mode(cdr_stream::stream_mode::max, key);
  return max(str, instance, props.data()); 
}

template<>
const propvec &get_type_props<::networkDataStructures::PIDCoeff>();

namespace {
  static const volatile propvec &properties___networkDataStructures__PIDCoeff = get_type_props<::networkDataStructures::PIDCoeff>();
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool write(T& streamer, const ::networkDataStructures::PIDCoeff& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.channel()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!write_string(streamer, instance.controlName(), 0))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 2:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.kP()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 3:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.kI()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 4:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.kD()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 5:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.bias()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 6:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.outputMax()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 7:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.outputMin()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 8:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.windupMax()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 9:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.windupMin()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 10:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.deadbandMax()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 11:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.deadbandMin()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 12:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.inputMap()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 13:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.outputMap()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 14:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.voltsConversion()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 15:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.controlUpdateSelector()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool write(S& str, const ::networkDataStructures::PIDCoeff& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::PIDCoeff>();
  str.set_mode(cdr_stream::stream_mode::write, key);
  return write(str, instance, props.data()); 
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool read(T& streamer, ::networkDataStructures::PIDCoeff& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.channel()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!read_string(streamer, instance.controlName(), 0))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 2:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.kP()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 3:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.kI()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 4:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.kD()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 5:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.bias()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 6:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.outputMax()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 7:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.outputMin()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 8:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.windupMax()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 9:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.windupMin()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 10:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.deadbandMax()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 11:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.deadbandMin()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 12:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.inputMap()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 13:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.outputMap()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 14:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.voltsConversion()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 15:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.controlUpdateSelector()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool read(S& str, ::networkDataStructures::PIDCoeff& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::PIDCoeff>();
  str.set_mode(cdr_stream::stream_mode::read, key);
  return read(str, instance, props.data()); 
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool move(T& streamer, const ::networkDataStructures::PIDCoeff& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.channel()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!move_string(streamer, instance.controlName(), 0))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 2:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.kP()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 3:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.kI()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 4:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.kD()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 5:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.bias()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 6:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.outputMax()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 7:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.outputMin()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 8:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.windupMax()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 9:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.windupMin()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 10:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.deadbandMax()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 11:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.deadbandMin()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 12:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.inputMap()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 13:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.outputMap()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 14:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.voltsConversion()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 15:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.controlUpdateSelector()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool move(S& str, const ::networkDataStructures::PIDCoeff& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::PIDCoeff>();
  str.set_mode(cdr_stream::stream_mode::move, key);
  return move(str, instance, props.data()); 
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool max(T& streamer, const ::networkDataStructures::PIDCoeff& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.channel()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!max_string(streamer, instance.controlName(), 0))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 2:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.kP()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 3:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.kI()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 4:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.kD()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 5:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.bias()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 6:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.outputMax()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 7:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.outputMin()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 8:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.windupMax()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 9:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.windupMin()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 10:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.deadbandMax()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 11:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.deadbandMin()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 12:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.inputMap()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 13:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.outputMap()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 14:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.voltsConversion()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 15:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.controlUpdateSelector()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool max(S& str, const ::networkDataStructures::PIDCoeff& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::PIDCoeff>();
  str.set_mode(cdr_stream::stream_mode::max, key);
  return max(str, instance, props.data()); 
}

template<>
const propvec &get_type_props<::networkDataStructures::PIDControls>();

namespace {
  static const volatile propvec &properties___networkDataStructures__PIDControls = get_type_props<::networkDataStructures::PIDControls>();
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool write(T& streamer, const ::networkDataStructures::PIDControls& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.channel()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.setpoint()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 2:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.manualOP()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 3:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.autoCtrl()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 4:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.clamped()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool write(S& str, const ::networkDataStructures::PIDControls& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::PIDControls>();
  str.set_mode(cdr_stream::stream_mode::write, key);
  return write(str, instance, props.data()); 
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool read(T& streamer, ::networkDataStructures::PIDControls& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.channel()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.setpoint()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 2:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.manualOP()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 3:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.autoCtrl()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 4:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.clamped()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool read(S& str, ::networkDataStructures::PIDControls& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::PIDControls>();
  str.set_mode(cdr_stream::stream_mode::read, key);
  return read(str, instance, props.data()); 
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool move(T& streamer, const ::networkDataStructures::PIDControls& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.channel()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.setpoint()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 2:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.manualOP()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 3:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.autoCtrl()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 4:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.clamped()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool move(S& str, const ::networkDataStructures::PIDControls& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::PIDControls>();
  str.set_mode(cdr_stream::stream_mode::move, key);
  return move(str, instance, props.data()); 
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool max(T& streamer, const ::networkDataStructures::PIDControls& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.channel()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.setpoint()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 2:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.manualOP()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 3:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.autoCtrl()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 4:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.clamped()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool max(S& str, const ::networkDataStructures::PIDControls& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::PIDControls>();
  str.set_mode(cdr_stream::stream_mode::max, key);
  return max(str, instance, props.data()); 
}

template<>
const propvec &get_type_props<::networkDataStructures::PIDState>();

namespace {
  static const volatile propvec &properties___networkDataStructures__PIDState = get_type_props<::networkDataStructures::PIDState>();
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool write(T& streamer, const ::networkDataStructures::PIDState& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!write(streamer, instance.machineID3()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, false))
        return false;
      for (const auto & a_1:instance.pidIO()) {  //array depth 1
      if (!write(streamer, a_1, prop))
        return false;
      }  //array depth 1
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 2:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, false))
        return false;
      for (const auto & a_1:instance.pidCoeffs()) {  //array depth 1
      if (!write(streamer, a_1, prop))
        return false;
      }  //array depth 1
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 3:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, false))
        return false;
      for (const auto & a_1:instance.pidControls()) {  //array depth 1
      if (!write(streamer, a_1, prop))
        return false;
      }  //array depth 1
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool write(S& str, const ::networkDataStructures::PIDState& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::PIDState>();
  str.set_mode(cdr_stream::stream_mode::write, key);
  return write(str, instance, props.data()); 
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool read(T& streamer, ::networkDataStructures::PIDState& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!read(streamer, instance.machineID3()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, false))
        return false;
      for (auto & a_1:instance.pidIO()) {  //array depth 1
      if (!read(streamer, a_1, prop))
        return false;
      }  //array depth 1
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 2:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, false))
        return false;
      for (auto & a_1:instance.pidCoeffs()) {  //array depth 1
      if (!read(streamer, a_1, prop))
        return false;
      }  //array depth 1
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 3:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, false))
        return false;
      for (auto & a_1:instance.pidControls()) {  //array depth 1
      if (!read(streamer, a_1, prop))
        return false;
      }  //array depth 1
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool read(S& str, ::networkDataStructures::PIDState& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::PIDState>();
  str.set_mode(cdr_stream::stream_mode::read, key);
  return read(str, instance, props.data()); 
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool move(T& streamer, const ::networkDataStructures::PIDState& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!move(streamer, instance.machineID3()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, false))
        return false;
      for (const auto & a_1:instance.pidIO()) {  //array depth 1
      if (!move(streamer, a_1, prop))
        return false;
      }  //array depth 1
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 2:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, false))
        return false;
      for (const auto & a_1:instance.pidCoeffs()) {  //array depth 1
      if (!move(streamer, a_1, prop))
        return false;
      }  //array depth 1
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 3:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, false))
        return false;
      for (const auto & a_1:instance.pidControls()) {  //array depth 1
      if (!move(streamer, a_1, prop))
        return false;
      }  //array depth 1
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool move(S& str, const ::networkDataStructures::PIDState& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::PIDState>();
  str.set_mode(cdr_stream::stream_mode::move, key);
  return move(str, instance, props.data()); 
}

template<typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true >
bool max(T& streamer, const ::networkDataStructures::PIDState& instance, const entity_properties_t *props) {
  (void)instance;
  member_id_set member_ids;
  if (!streamer.start_struct(*props))
    return false;
  auto prop = streamer.first_entity(props);
  while (prop) {
    switch (prop->m_id) {
      case 0:
      if (!streamer.start_member(*prop))
        return false;
      if (!max(streamer, instance.machineID3()))
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 1:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, false))
        return false;
      for (const auto & a_1:instance.pidIO()) {  //array depth 1
      if (!max(streamer, a_1, prop))
        return false;
      }  //array depth 1
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 2:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, false))
        return false;
      for (const auto & a_1:instance.pidCoeffs()) {  //array depth 1
      if (!max(streamer, a_1, prop))
        return false;
      }  //array depth 1
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
      case 3:
      if (!streamer.start_member(*prop))
        return false;
      if (!streamer.start_consecutive(true, false))
        return false;
      for (const auto & a_1:instance.pidControls()) {  //array depth 1
      if (!max(streamer, a_1, prop))
        return false;
      }  //array depth 1
      if (!streamer.finish_consecutive())
        return false;
      if (!streamer.finish_member(*prop, member_ids))
        return false;
      break;
    }
    prop = streamer.next_entity(prop);
  }
  return streamer.finish_struct(*props, member_ids);
}

template<typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true >
bool max(S& str, const ::networkDataStructures::PIDState& instance, key_mode key) {
  const auto &props = get_type_props<::networkDataStructures::PIDState>();
  str.set_mode(cdr_stream::stream_mode::max, key);
  return max(str, instance, props.data()); 
}

} //namespace cdr
} //namespace core
} //namespace cyclonedds
} //namespace eclipse
} //namespace org

#endif // DDSCXX__HOME_ERICWSL_CPROJECTS_UEIDAQ_CORE_BOOST_CYCLONEDDSCXX_BUILD_NETWORKDATASTRUCTURES_HPP_766278EA1375CB10BEDF72992B227068
