/****************************************************************

  Generated by Eclipse Cyclone DDS IDL to CXX Translator
  File name: /home/eric-wsl/CProjects/UEIDAQ-core-boost-cycloneDDScxx/networkDataStructures.idl
  Source: /home/eric-wsl/CProjects/UEIDAQ-core-boost-cycloneDDScxx/build/networkDataStructures.cpp
  Cyclone DDS: v0.11.0

*****************************************************************/
#include "networkDataStructures.hpp"

namespace org{
namespace eclipse{
namespace cyclonedds{
namespace core{
namespace cdr{

template<>
const propvec &get_type_props<::networkDataStructures::Msg>() {
  static std::mutex mtx;
  static propvec props;
  static std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed))
    return props;
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed))
    return props;
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<int32_t>(), extensibility::ext_final, false));  //::userID
  props.push_back(entity_properties_t(1, 1, false, bit_bound::bb_unset, extensibility::ext_final, false));  //::message
  keylist.add_key_endpoint(std::list<uint32_t>{0});

  entity_properties_t::finish(props, keylist);
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
const propvec &get_type_props<::networkDataStructures::ChInfo>() {
  static std::mutex mtx;
  static propvec props;
  static std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed))
    return props;
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed))
    return props;
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::machineID
  props.push_back(entity_properties_t(1, 1, false, bit_bound::bb_unset, extensibility::ext_final, false));  //::ChInfoString
  keylist.add_key_endpoint(std::list<uint32_t>{0});

  entity_properties_t::finish(props, keylist);
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
const propvec &get_type_props<::networkDataStructures::BundleStruct>() {
  static std::mutex mtx;
  static propvec props;
  static std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed))
    return props;
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed))
    return props;
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::machineID
  props.push_back(entity_properties_t(1, 1, false, get_bit_bound<uint64_t>(), extensibility::ext_final, false));  //::iteration
  props.push_back(entity_properties_t(1, 2, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::aiBundle
  props.push_back(entity_properties_t(1, 3, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::aoBundle
  props.push_back(entity_properties_t(1, 4, false, get_bit_bound<bool>(), extensibility::ext_final, false));  //::roBundle
  props.push_back(entity_properties_t(1, 5, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::calcBundle
  keylist.add_key_endpoint(std::list<uint32_t>{0});

  entity_properties_t::finish(props, keylist);
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
const propvec &get_type_props<::networkDataStructures::PIDIO>() {
  static std::mutex mtx;
  static propvec props;
  static std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed))
    return props;
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed))
    return props;
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::channel
  props.push_back(entity_properties_t(1, 1, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::PV
  props.push_back(entity_properties_t(1, 2, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::SP
  props.push_back(entity_properties_t(1, 3, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::OP
  props.push_back(entity_properties_t(1, 4, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::manOP

  entity_properties_t::finish(props, keylist);
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
const propvec &get_type_props<::networkDataStructures::PIDCoeff>() {
  static std::mutex mtx;
  static propvec props;
  static std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed))
    return props;
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed))
    return props;
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::channel
  props.push_back(entity_properties_t(1, 1, false, bit_bound::bb_unset, extensibility::ext_final, false));  //::controlName
  props.push_back(entity_properties_t(1, 2, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::kP
  props.push_back(entity_properties_t(1, 3, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::kI
  props.push_back(entity_properties_t(1, 4, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::kD
  props.push_back(entity_properties_t(1, 5, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::bias
  props.push_back(entity_properties_t(1, 6, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::outputMax
  props.push_back(entity_properties_t(1, 7, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::outputMin
  props.push_back(entity_properties_t(1, 8, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::windupMax
  props.push_back(entity_properties_t(1, 9, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::windupMin
  props.push_back(entity_properties_t(1, 10, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::deadbandMax
  props.push_back(entity_properties_t(1, 11, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::deadbandMin
  props.push_back(entity_properties_t(1, 12, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::inputMap
  props.push_back(entity_properties_t(1, 13, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::outputMap
  props.push_back(entity_properties_t(1, 14, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::voltsConversion
  props.push_back(entity_properties_t(1, 15, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::controlUpdateSelector

  entity_properties_t::finish(props, keylist);
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
const propvec &get_type_props<::networkDataStructures::PIDControls>() {
  static std::mutex mtx;
  static propvec props;
  static std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed))
    return props;
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed))
    return props;
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::channel
  props.push_back(entity_properties_t(1, 1, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::setpoint
  props.push_back(entity_properties_t(1, 2, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::manualOP
  props.push_back(entity_properties_t(1, 3, false, get_bit_bound<bool>(), extensibility::ext_final, false));  //::autoCtrl
  props.push_back(entity_properties_t(1, 4, false, get_bit_bound<bool>(), extensibility::ext_final, false));  //::clamped

  entity_properties_t::finish(props, keylist);
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
const propvec &get_type_props<::networkDataStructures::PIDState>() {
  static std::mutex mtx;
  static propvec props;
  static std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed))
    return props;
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed))
    return props;
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::machineID3
  props.push_back(entity_properties_t(1, 1, false, get_bit_bound<::networkDataStructures::PIDIO>(), extensibility::ext_final, false));  //::pidIO
  entity_properties_t::append_struct_contents(props, get_type_props<::networkDataStructures::PIDIO>());  //internal contents of ::pidIO
  props.push_back(entity_properties_t(1, 2, false, get_bit_bound<::networkDataStructures::PIDCoeff>(), extensibility::ext_final, false));  //::pidCoeffs
  entity_properties_t::append_struct_contents(props, get_type_props<::networkDataStructures::PIDCoeff>());  //internal contents of ::pidCoeffs
  props.push_back(entity_properties_t(1, 3, false, get_bit_bound<::networkDataStructures::PIDControls>(), extensibility::ext_final, false));  //::pidControls
  entity_properties_t::append_struct_contents(props, get_type_props<::networkDataStructures::PIDControls>());  //internal contents of ::pidControls
  keylist.add_key_endpoint(std::list<uint32_t>{0});

  entity_properties_t::finish(props, keylist);
  initialized.store(true, std::memory_order_release);
  return props;
}

} //namespace cdr
} //namespace core
} //namespace cyclonedds
} //namespace eclipse
} //namespace org

